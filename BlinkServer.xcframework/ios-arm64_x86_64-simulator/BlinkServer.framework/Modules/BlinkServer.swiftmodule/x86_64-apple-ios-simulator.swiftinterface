// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.1 (swiftlang-5.7.1.135.3 clang-1400.0.29.51)
// swift-module-flags: -target x86_64-apple-ios13.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name BlinkServer
// swift-module-flags-ignorable: -enable-bare-slash-regex
@_exported import BlinkServer
import CoreGraphics.CGBase
import Combine
import CommonCrypto
import CoreBluetooth
import CoreGraphics
import CryptoKit
import Darwin
import Foundation
import Swift
import UIKit
import _Concurrency
import _StringProcessing
@frozen public struct AnyDecodable : Swift.Decodable {
  public let value: Any
  public init<T>(_ value: T?)
}
@usableFromInline
internal protocol _AnyDecodable {
  var value: Any { get }
  init<T>(_ value: T?)
}
extension BlinkServer.AnyDecodable : BlinkServer._AnyDecodable {
}
extension BlinkServer._AnyDecodable {
  public init(from decoder: Swift.Decoder) throws
}
extension BlinkServer.AnyDecodable : Swift.Equatable {
  public static func == (lhs: BlinkServer.AnyDecodable, rhs: BlinkServer.AnyDecodable) -> Swift.Bool
}
extension BlinkServer.AnyDecodable : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension BlinkServer.AnyDecodable : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@_transparent public func acos(_ value: BlinkServer.Half) -> BlinkServer.Half {
    return Half(acos(Float(value)))
}
@_transparent public func acosh(_ value: BlinkServer.Half) -> BlinkServer.Half {
    return Half(acosh(Float(value)))
}
@_transparent public func asin(_ value: BlinkServer.Half) -> BlinkServer.Half {
    return Half(asin(Float(value)))
}
@_transparent public func asinh(_ value: BlinkServer.Half) -> BlinkServer.Half {
    return Half(asinh(Float(value)))
}
@_transparent public func atan(_ value: BlinkServer.Half) -> BlinkServer.Half {
    return Half(atan(Float(value)))
}
@_transparent public func atanh(_ value: BlinkServer.Half) -> BlinkServer.Half {
    return Half(atanh(Float(value)))
}
@_transparent public func cbrt(_ value: BlinkServer.Half) -> BlinkServer.Half {
    return Half(cbrt(Float(value)))
}
@_transparent public func cos(_ value: BlinkServer.Half) -> BlinkServer.Half {
    return Half(cos(Float(value)))
}
@_transparent public func cosh(_ value: BlinkServer.Half) -> BlinkServer.Half {
    return Half(cosh(Float(value)))
}
@_transparent public func erf(_ value: BlinkServer.Half) -> BlinkServer.Half {
    return Half(erf(Float(value)))
}
@_transparent public func erfc(_ value: BlinkServer.Half) -> BlinkServer.Half {
    return Half(erfc(Float(value)))
}
@_transparent public func exp(_ value: BlinkServer.Half) -> BlinkServer.Half {
    return Half(exp(Float(value)))
}
@_transparent public func exp2(_ value: BlinkServer.Half) -> BlinkServer.Half {
    return Half(exp2(Float(value)))
}
@_transparent public func expm1(_ value: BlinkServer.Half) -> BlinkServer.Half {
    return Half(expm1(Float(value)))
}
@_transparent public func log(_ value: BlinkServer.Half) -> BlinkServer.Half {
    return Half(log(Float(value)))
}
@_transparent public func log10(_ value: BlinkServer.Half) -> BlinkServer.Half {
    return Half(log10(Float(value)))
}
@_transparent public func log1p(_ value: BlinkServer.Half) -> BlinkServer.Half {
    return Half(log1p(Float(value)))
}
@_transparent public func log2(_ value: BlinkServer.Half) -> BlinkServer.Half {
    return Half(log2(Float(value)))
}
@_transparent public func logb(_ value: BlinkServer.Half) -> BlinkServer.Half {
    return Half(logb(Float(value)))
}
@_transparent public func nearbyint(_ value: BlinkServer.Half) -> BlinkServer.Half {
    return Half(nearbyint(Float(value)))
}
@_transparent public func rint(_ value: BlinkServer.Half) -> BlinkServer.Half {
    return Half(rint(Float(value)))
}
@_transparent public func sin(_ value: BlinkServer.Half) -> BlinkServer.Half {
    return Half(sin(Float(value)))
}
@_transparent public func sinh(_ value: BlinkServer.Half) -> BlinkServer.Half {
    return Half(sinh(Float(value)))
}
@_transparent public func tan(_ value: BlinkServer.Half) -> BlinkServer.Half {
    return Half(tan(Float(value)))
}
@_transparent public func tanh(_ value: BlinkServer.Half) -> BlinkServer.Half {
    return Half(tanh(Float(value)))
}
@_transparent public func tgamma(_ value: BlinkServer.Half) -> BlinkServer.Half {
    return Half(tgamma(Float(value)))
}
@_transparent public func atan2(_ lhs: BlinkServer.Half, _ rhs: BlinkServer.Half) -> BlinkServer.Half {
    return Half(atan2(Float(lhs), Float(rhs)))
}
@_transparent public func copysign(_ lhs: BlinkServer.Half, _ rhs: BlinkServer.Half) -> BlinkServer.Half {
    return Half(copysign(Float(lhs), Float(rhs)))
}
@_transparent public func fdim(_ lhs: BlinkServer.Half, _ rhs: BlinkServer.Half) -> BlinkServer.Half {
    return Half(fdim(Float(lhs), Float(rhs)))
}
@_transparent public func fmax(_ lhs: BlinkServer.Half, _ rhs: BlinkServer.Half) -> BlinkServer.Half {
    return Half(fmax(Float(lhs), Float(rhs)))
}
@_transparent public func fmin(_ lhs: BlinkServer.Half, _ rhs: BlinkServer.Half) -> BlinkServer.Half {
    return Half(fmin(Float(lhs), Float(rhs)))
}
@_transparent public func hypot(_ lhs: BlinkServer.Half, _ rhs: BlinkServer.Half) -> BlinkServer.Half {
    return Half(hypot(Float(lhs), Float(rhs)))
}
@_transparent public func nextafter(_ lhs: BlinkServer.Half, _ rhs: BlinkServer.Half) -> BlinkServer.Half {
    return Half(nextafter(Float(lhs), Float(rhs)))
}
@_transparent public func pow(_ lhs: BlinkServer.Half, _ rhs: BlinkServer.Half) -> BlinkServer.Half {
    return Half(pow(Float(lhs), Float(rhs)))
}
@_transparent public func lgamma(_ value: BlinkServer.Half) -> (BlinkServer.Half, Swift.Int) {
    let result = lgamma(Float(value))
    return (Half(result.0), result.1)
}
@_transparent public func remquo(_ lhs: BlinkServer.Half, _ rhs: BlinkServer.Half) -> (BlinkServer.Half, Swift.Int) {
    let result = remquo(Float(lhs), Float(rhs))
    return (Half(result.0), result.1)
}
public protocol BlinkDelegate : AnyObject {
  func didSendPacket(type: Swift.String, central: CoreBluetooth.CBCentral)
  func openLockerWithToken(request: BlinkServer.BlinkOpenLockerRequest, completionHandler: (_ lockerId: Swift.Int, _ error: Foundation.NSError?) -> Swift.Void)
}
public typealias OpenLockerWithTokenResponseHandler = (_ lockerId: Swift.Int, _ error: Foundation.NSError?) -> Swift.Void
@_hasMissingDesignatedInitializers @objc @objcMembers public class BlinkManager : ObjectiveC.NSObject {
  @objc final public let serviceUuid: CoreBluetooth.CBUUID
  @objc final public let rxCharacteristicUuid: CoreBluetooth.CBUUID
  @objc final public let txCharacteristicUuid: CoreBluetooth.CBUUID
  weak public var delegate: BlinkServer.BlinkDelegate?
  @objc public var loggerDelegate: BlinkServer.BlinkLoggerDelegate?
  @objc public var logLevel: BlinkServer.BlinkLogLevel
  public static func initService(peripheralManager: CoreBluetooth.CBPeripheralManager, keys: BlinkServer.BlinkKeys) throws -> BlinkServer.BlinkManager
  @objc public func startService()
  @objc public func stopService()
  @objc deinit
}
extension BlinkServer.BlinkManager {
  @objc dynamic public func didReceiveWrite(peripheral: CoreBluetooth.CBPeripheralManager, request: CoreBluetooth.CBATTRequest)
  @objc dynamic public func didReceiveRead(peripheral: CoreBluetooth.CBPeripheralManager, request: CoreBluetooth.CBATTRequest)
}
@objc public protocol BlinkLoggerDelegate {
  @objc func blinkDidLog(message: Swift.String, logType: BlinkServer.BlinkLogLevel, context: [Swift.String : Any]?)
}
@_hasMissingDesignatedInitializers public class BlinkLogger {
  @objc deinit
}
@_hasMissingDesignatedInitializers public class BlinkStruct : BlinkServer.BLinkProtocolPacket {
  required public init(map: [Swift.Int : BlinkServer.AnyCodable]) throws
  public func toMap() throws -> [Swift.Int : BlinkServer.AnyCodable]
  @objc deinit
}
public protocol BLinkProtocolPacket {
  init(map: [Swift.Int : BlinkServer.AnyCodable]) throws
  func toMap() throws -> [Swift.Int : BlinkServer.AnyCodable]
}
@frozen public struct Half {
  public var _value: BlinkServer.half_t
  @_transparent public init() {
        self._value = _half_zero()
    }
  @_transparent public init(_ _value: BlinkServer.half_t) {
        self._value = _value
    }
}
extension BlinkServer.Half {
  @inlinable public var bitPattern: Swift.UInt16 {
    get {
        return _half_to_raw(_value)
    }
  }
  @inlinable public init(bitPattern: Swift.UInt16) {
        self._value = _half_from_raw(bitPattern)
    }
  @inlinable public init(nan payload: Swift.UInt16, signaling: Swift.Bool) {
        precondition(payload < (Half.quietNaNMask &>> 1), "NaN payload is not encodable.")

        var significand = payload
        significand |= Half.quietNaNMask &>> (signaling ? 1 : 0)

        self.init(sign: .plus, exponentBitPattern: Half.infinityExponent, significandBitPattern: significand)
    }
}
extension BlinkServer.Half : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension BlinkServer.Half : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension BlinkServer.Half : Swift.TextOutputStreamable {
  public func write<Target>(to target: inout Target) where Target : Swift.TextOutputStream
}
extension BlinkServer.Half {
  @inlinable @inline(__always) internal static var significandMask: Swift.UInt16 {
    get {
        return 1 &<< UInt16(significandBitCount) - 1
    }
  }
  @inlinable @inline(__always) internal static var infinityExponent: Swift.UInt {
    get {
        return 1 &<< UInt(exponentBitCount) - 1
    }
  }
  @inlinable @inline(__always) internal static var exponentBias: Swift.UInt {
    get {
        return infinityExponent &>> 1
    }
  }
  @inlinable @inline(__always) internal static var quietNaNMask: Swift.UInt16 {
    get {
        return 1 &<< UInt16(significandBitCount - 1)
    }
  }
}
extension BlinkServer.Half : Swift.BinaryFloatingPoint {
  @inlinable public static var exponentBitCount: Swift.Int {
    get {
        return 5
    }
  }
  @inlinable public static var significandBitCount: Swift.Int {
    get {
        return 10
    }
  }
  @inlinable public var exponentBitPattern: Swift.UInt {
    get {
        return UInt(bitPattern &>> UInt16(Half.significandBitCount)) & Half.infinityExponent
    }
  }
  @inlinable public var significandBitPattern: Swift.UInt16 {
    get {
        return bitPattern & Half.significandMask
    }
  }
  @inlinable public init(sign: Swift.FloatingPointSign, exponentBitPattern: Swift.UInt, significandBitPattern: Swift.UInt16) {
        let signBits: UInt16 = (sign == .minus ? 1 : 0) &<< (Half.exponentBitCount + Half.significandBitCount)
        let exponentBits = UInt16((exponentBitPattern & Half.infinityExponent) &<< Half.significandBitCount)
        let significandBits = significandBitPattern & Half.significandMask

        self.init(bitPattern: signBits | exponentBits | significandBits)
    }
  @inlinable @inline(__always) public init(_ other: Swift.Float) {
        if other.isInfinite {
            let infinity = Half.infinity
            self = Half(sign: other.sign, exponentBitPattern: infinity.exponentBitPattern, significandBitPattern: infinity.significandBitPattern)
        } else if other.isNaN {
            self = .nan
        } else {
            _value = _half_from(other)
        }
    }
  @inlinable @inline(__always) public init(_ other: Swift.Double) {
        if other.isInfinite {
            let infinity = Half.infinity
            self = Half(sign: other.sign, exponentBitPattern: infinity.exponentBitPattern, significandBitPattern: infinity.significandBitPattern)
        } else if other.isNaN {
            self = .nan
        } else {
            _value = _half_from(other)
        }
    }
  @inlinable @inline(__always) public init(_ other: Swift.Float80) {
        if other.isInfinite {
            let infinity = Half.infinity
            self = Half(sign: other.sign, exponentBitPattern: infinity.exponentBitPattern, significandBitPattern: infinity.significandBitPattern)
        } else if other.isNaN {
            self = .nan
        } else {
            _value = _half_from(Double(other))
        }
    }
  @inlinable @inline(__always) public init(_ other: CoreFoundation.CGFloat) {
        self.init(other.native)
    }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @inlinable @inline(__always) public init(_ other: Swift.Float16) {
        if other.isInfinite {
            let infinity = Half.infinity
            self = Half(sign: other.sign, exponentBitPattern: infinity.exponentBitPattern, significandBitPattern: infinity.significandBitPattern)
        } else if other.isNaN {
            self = .nan
        } else {
            self.init(bitPattern: other.bitPattern)
        }
    }
  @inlinable @inline(__always) public init<Source>(_ value: Source) where Source : Swift.BinaryFloatingPoint {
        if let half = value as? Half {
            self.init(half._value)
        } else if value.isInfinite {
            let infinity = Half.infinity
            self = Half(sign: value.sign, exponentBitPattern: infinity.exponentBitPattern, significandBitPattern: infinity.significandBitPattern)
        } else if value.isNaN {
            if value.isSignalingNaN {
                self = .signalingNaN
            } else {
                self = .nan
            }
        } else {
            self.init(_half_from(Float(value)))
        }
    }
  @inlinable public init?<Source>(exactly value: Source) where Source : Swift.BinaryFloatingPoint {
        self.init(value)

        if isInfinite || value.isInfinite {
            if value.isInfinite && (!isInfinite || sign != value.sign) {
                // If source is infinite but this isn't or this is but with a different sign
                return nil
            } else if isInfinite && !value.isInfinite {
                // If source isn't infinite but this is
                return nil
            }
        } else if isNaN || value.isNaN {
            if value.isNaN && (!isNaN || isSignalingNaN != value.isSignalingNaN) {
                // If source is NaN but this isn't or this is but one is signaling while the other isn't
                return nil
            } else if isNaN && !value.isNaN {
                // If source isn't NaN but this is
                return nil
            }
        } else if Source(self) != value {
            // If casting half back to source isn't equal to original source
            return nil
        }
    }
  @inlinable public var binade: BlinkServer.Half {
    get {
        guard isFinite else { return .nan }

        if isSubnormal {
            let bitPattern = (self * 0x1p10).bitPattern & (-Half.infinity).bitPattern
            return Half(bitPattern: bitPattern) * .ulpOfOne
        }

        return Half(bitPattern: bitPattern & (-Half.infinity).bitPattern)
    }
  }
  @inlinable public var significandWidth: Swift.Int {
    get {
        let trailingZeroBits = significandBitPattern.trailingZeroBitCount
        if isNormal {
            guard significandBitPattern != 0 else { return 0 }
            return Half.significandBitCount &- trailingZeroBits
        }
        if isSubnormal {
            let leadingZeroBits = significandBitPattern.leadingZeroBitCount
            return UInt16.bitWidth &- (trailingZeroBits &+ leadingZeroBits &+ 1)
        }
        return -1
    }
  }
  public typealias RawExponent = Swift.UInt
  public typealias RawSignificand = Swift.UInt16
}
extension BlinkServer.Half : Swift.ExpressibleByFloatLiteral {
  @_transparent public init(floatLiteral value: Swift.Float) {
        self.init(value)
    }
  public typealias FloatLiteralType = Swift.Float
}
extension BlinkServer.Half : Swift.FloatingPoint {
  @inlinable public init(sign: Swift.FloatingPointSign, exponent: Swift.Int, significand: BlinkServer.Half) {
        var result = significand
        if sign == .minus { result = -result }

        if significand.isFinite && !significand.isZero {
            var clamped = exponent
            let leastNormalExponent = 1 - Int(Half.exponentBias)
            let greatestFiniteExponent = Int(Half.exponentBias)

            if clamped < leastNormalExponent {
                clamped = max(clamped, 3 * leastNormalExponent)

                while clamped < leastNormalExponent {
                    result *= Half.leastNormalMagnitude
                    clamped -= leastNormalExponent
                }
            } else if clamped > greatestFiniteExponent {
                let step = Half(sign: .plus, exponentBitPattern: Half.infinityExponent - 1, significandBitPattern: 0)
                clamped = min(clamped, 3 * greatestFiniteExponent)

                while clamped > greatestFiniteExponent {
                    result *= step
                    clamped -= greatestFiniteExponent
                }
            }

            let scale = Half(sign: .plus, exponentBitPattern: UInt(Int(Half.exponentBias) + clamped), significandBitPattern: 0)
            result *= scale
        }

        self = result
    }
  @_transparent public init(_ value: Swift.Int) {
        _value = _half_from(value)
    }
  @inlinable @inline(__always) public init<Source>(_ value: Source) where Source : Swift.BinaryInteger {
        if value.bitWidth <= MemoryLayout<Int>.size * 8 {
            if Source.isSigned {
                let asInt = Int(truncatingIfNeeded: value)
                self.init(_half_from(asInt))
            } else {
                let asUInt = UInt(truncatingIfNeeded: value)
                self.init(_half_from(asUInt))
            }
        } else {
            self.init(Float(value))
        }
    }
  @inlinable public var exponent: Swift.Int {
    get {
        if !isFinite { return .max }
        if isZero { return .min }

        let provisional = Int(exponentBitPattern) - Int(Half.exponentBias)
        if isNormal { return provisional }

        let shift = Half.significandBitCount - Int(significandBitPattern._binaryLogarithm())
        return provisional + 1 - shift
    }
  }
  @inlinable public var isCanonical: Swift.Bool {
    get {

        return true
    }
  }
  @inlinable @inline(__always) public var isFinite: Swift.Bool {
    get {
        return exponentBitPattern < Half.infinityExponent
    }
  }
  @inlinable @inline(__always) public var isInfinite: Swift.Bool {
    get {
        return !isFinite && significandBitPattern == 0
    }
  }
  @inlinable @inline(__always) public var isNaN: Swift.Bool {
    get {
        return !isFinite && significandBitPattern != 0
    }
  }
  @inlinable @inline(__always) public var isNormal: Swift.Bool {
    get {
        return exponentBitPattern > 0 && isFinite
    }
  }
  @inlinable @inline(__always) public var isSignalingNaN: Swift.Bool {
    get {
        return isNaN && (significandBitPattern & Half.quietNaNMask) == 0
    }
  }
  @inlinable @inline(__always) public var isSubnormal: Swift.Bool {
    get {
        return exponentBitPattern == 0 && significandBitPattern != 0
    }
  }
  @inlinable @inline(__always) public var isZero: Swift.Bool {
    get {
        return exponentBitPattern == 0 && significandBitPattern == 0
    }
  }
  @inlinable public var nextUp: BlinkServer.Half {
    get {
        let next = self + 0


        if next < .infinity {
            let increment = Int16(bitPattern: next.bitPattern) &>> 15 | 1
            let bitPattern = next.bitPattern &+ UInt16(bitPattern: increment)
            return Half(bitPattern: bitPattern)
        }

        return next
    }
  }
  @inlinable public var sign: Swift.FloatingPointSign {
    get {
        let shift = Half.significandBitCount + Half.exponentBitCount
        // swiftlint:disable force_unwrapping
        return FloatingPointSign(rawValue: Int(bitPattern &>> UInt16(shift)))!
        // swiftlint:enable force_unwrapping
    }
  }
  @inlinable public var significand: BlinkServer.Half {
    get {
        if isNaN { return self }
        if isNormal {
            return Half(sign: .plus, exponentBitPattern: Half.exponentBias, significandBitPattern: significandBitPattern)
        }

        if isSubnormal {
            let shift = Half.significandBitCount - Int(significandBitPattern._binaryLogarithm())
            return Half(sign: .plus, exponentBitPattern: Half.exponentBias, significandBitPattern: significandBitPattern &<< shift)
        }

        return Half(sign: .plus, exponentBitPattern: exponentBitPattern, significandBitPattern: 0)
    }
  }
  @inlinable public var ulp: BlinkServer.Half {
    get {
        guard isFinite else { return .nan }
        if isNormal {
            let bitPattern = self.bitPattern & Half.infinity.bitPattern
            return Half(bitPattern: bitPattern) * .ulpOfOne
        }

        return .leastNormalMagnitude * .ulpOfOne
    }
  }
  @inlinable public static var greatestFiniteMagnitude: BlinkServer.Half {
    get {
        return Half(bitPattern: 0x7BFF)
    }
  }
  @inlinable public static var infinity: BlinkServer.Half {
    get {
        return Half(bitPattern: 0x7C00)
    }
  }
  @inlinable public static var leastNonzeroMagnitude: BlinkServer.Half {
    get {
        return Half(sign: .plus, exponentBitPattern: 0, significandBitPattern: 1)
    }
  }
  @inlinable public static var leastNormalMagnitude: BlinkServer.Half {
    get {
        return Half(sign: .plus, exponentBitPattern: 1, significandBitPattern: 0)
    }
  }
  @inlinable public static var nan: BlinkServer.Half {
    get {
        return Half(_half_nan())
    }
  }
  @inlinable public static var pi: BlinkServer.Half {
    get {
        return Half(_half_pi())
    }
  }
  @inlinable public static var signalingNaN: BlinkServer.Half {
    get {
        return Half(nan: 0, signaling: true)
    }
  }
  @inlinable public static var ulpOfOne: BlinkServer.Half {
    get {
        return Half(_half_epsilon())
    }
  }
  @_transparent public mutating func addProduct(_ lhs: BlinkServer.Half, _ rhs: BlinkServer.Half) {
        _value = _half_fma(_value, lhs._value, rhs._value)
    }
  @inlinable @inline(__always) public mutating func formRemainder(dividingBy other: BlinkServer.Half) {
        self = Half(Float(self).remainder(dividingBy: Float(other)))
    }
  @_transparent public mutating func formSquareRoot() {
        _value = _half_sqrt(_value)
    }
  @inlinable @inline(__always) public mutating func formTruncatingRemainder(dividingBy other: BlinkServer.Half) {
        self = Half(Float(self).truncatingRemainder(dividingBy: Float(other)))
    }
  @_transparent public func isEqual(to other: BlinkServer.Half) -> Swift.Bool {
        return Bool(_half_equal(self._value, other._value))
    }
  @_transparent public func isLess(than other: BlinkServer.Half) -> Swift.Bool {
        return Bool(_half_lt(self._value, other._value))
    }
  @_transparent public func isLessThanOrEqualTo(_ other: BlinkServer.Half) -> Swift.Bool {
        return Bool(_half_lte(self._value, other._value))
    }
  @_transparent public mutating func round(_ rule: Swift.FloatingPointRoundingRule) {
        self = Half(Float(self).rounded(rule))
    }
  @_transparent public static func / (lhs: BlinkServer.Half, rhs: BlinkServer.Half) -> BlinkServer.Half {
        return Half(_half_div(lhs._value, rhs._value))
    }
  @_transparent public static func /= (lhs: inout BlinkServer.Half, rhs: BlinkServer.Half) {
        lhs._value = _half_div(lhs._value, rhs._value)
    }
  public typealias Exponent = Swift.Int
}
extension BlinkServer.Half : Swift.Hashable {
  @inlinable public var hashValue: Swift.Int {
    get {
        var hasher = Hasher()
        self.hash(into: &hasher)
        return hasher.finalize()
    }
  }
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
        var value = self
        if isZero {
            value = 0 // to reconcile -0.0 and +0.0
        }

        hasher.combine(value.bitPattern)
    }
}
extension BlinkServer.Half : Swift.Strideable {
  @_transparent public func distance(to other: BlinkServer.Half) -> BlinkServer.Half {
        return other - self
    }
  @_transparent public func advanced(by amount: BlinkServer.Half) -> BlinkServer.Half {
        return self + amount
    }
  public typealias Stride = BlinkServer.Half
}
extension BlinkServer.Half : Swift.SignedNumeric {
  @_transparent public mutating func negate() {
        _value = _half_neg(_value)
    }
  @_transparent prefix public static func - (value: BlinkServer.Half) -> BlinkServer.Half {
        return Half(_half_neg(value._value))
    }
}
extension BlinkServer.Half : Swift.Numeric {
  @inlinable @inline(__always) public var magnitude: BlinkServer.Half {
    get {
        return Half(_half_abs(_value))
    }
  }
  @inlinable @inline(__always) public init?<Source>(exactly value: Source) where Source : Swift.BinaryInteger {
        self.init(value)

        if isInfinite || isNaN || Source(self) != value {
            return nil
        }
    }
  @_transparent public static func * (lhs: BlinkServer.Half, rhs: BlinkServer.Half) -> BlinkServer.Half {
        return Half(_half_mul(lhs._value, rhs._value))
    }
  @_transparent public static func *= (lhs: inout BlinkServer.Half, rhs: BlinkServer.Half) {
        lhs._value = _half_mul(lhs._value, rhs._value)
    }
  public typealias Magnitude = BlinkServer.Half
}
extension BlinkServer.Half : Swift.ExpressibleByIntegerLiteral {
  @_transparent public init(integerLiteral value: Swift.Int64) {
        self = Half(value)
    }
  public typealias IntegerLiteralType = Swift.Int64
}
extension BlinkServer.Half : Swift.AdditiveArithmetic {
  @_transparent public static func + (lhs: BlinkServer.Half, rhs: BlinkServer.Half) -> BlinkServer.Half {
        return Half(_half_add(lhs._value, rhs._value))
    }
  @_transparent public static func += (lhs: inout BlinkServer.Half, rhs: BlinkServer.Half) {
        lhs._value = _half_add(lhs._value, rhs._value)
    }
  @_transparent public static func - (lhs: BlinkServer.Half, rhs: BlinkServer.Half) -> BlinkServer.Half {
        return Half(_half_sub(lhs._value, rhs._value))
    }
  @_transparent public static func -= (lhs: inout BlinkServer.Half, rhs: BlinkServer.Half) {
        lhs._value = _half_sub(lhs._value, rhs._value)
    }
}
extension BlinkServer.Half : Swift.CustomReflectable {
  @_transparent public var customMirror: Swift.Mirror {
    @_transparent get {
        return Mirror(reflecting: Float(self))
    }
  }
}
extension BlinkServer.Half : Swift.CustomPlaygroundDisplayConvertible {
  @_transparent public var playgroundDescription: Any {
    @_transparent get {
        return Float(self)
    }
  }
}
extension Foundation.Data {
  public func cborHexStringFromJSON() -> Swift.String
  public func hexString() -> Swift.String
  public static func randomCryptoBytes(_ count: Swift.Int) throws -> Foundation.Data
  public init?(hexString: Swift.String)
}
extension Foundation.NSData {
  @objc dynamic public func initWith(hexString: Swift.String) -> Foundation.NSData?
  @objc dynamic public func cborHexStringFromJSON() -> Swift.String
  @objc dynamic public func hexString() -> Swift.String
  @objc public static func randomCryptoBytes(_ count: Swift.Int) -> Foundation.NSData?
}
extension BlinkServer.CBOR.NegativeUInt64 : Swift.Equatable {
  public static func == (lhs: BlinkServer.CBOR.NegativeUInt64, rhs: BlinkServer.CBOR.NegativeUInt64) -> Swift.Bool
}
extension BlinkServer.CBOR.SimpleValue : Swift.Equatable {
  public static func == (lhs: BlinkServer.CBOR.SimpleValue, rhs: BlinkServer.CBOR.SimpleValue) -> Swift.Bool
}
extension BlinkServer.CBOR.Bignum : Swift.Equatable {
  public static func == (lhs: BlinkServer.CBOR.Bignum, rhs: BlinkServer.CBOR.Bignum) -> Swift.Bool
}
extension BlinkServer.CBOR.DecimalFraction : Swift.Equatable {
  public static func == (lhs: BlinkServer.CBOR.DecimalFraction<I1, I2>, rhs: BlinkServer.CBOR.DecimalFraction<I1, I2>) -> Swift.Bool
}
extension BlinkServer.CBOR.Bigfloat : Swift.Equatable {
  public static func == (lhs: BlinkServer.CBOR.Bigfloat<I1, I2>, rhs: BlinkServer.CBOR.Bigfloat<I1, I2>) -> Swift.Bool
}
extension BlinkServer.CBOR.IndefiniteLengthArray : Swift.Equatable where Element : Swift.Equatable {
  public static func == (lhs: BlinkServer.CBOR.IndefiniteLengthArray<Element>, rhs: BlinkServer.CBOR.IndefiniteLengthArray<Element>) -> Swift.Bool
}
extension BlinkServer.CBOR.IndefiniteLengthMap : Swift.Equatable where Value : Swift.Equatable {
  public static func == (lhs: BlinkServer.CBOR.IndefiniteLengthMap<Key, Value>, rhs: BlinkServer.CBOR.IndefiniteLengthMap<Key, Value>) -> Swift.Bool
}
extension BlinkServer.CBOR.IndefiniteLengthData : Swift.Equatable {
  public static func == (lhs: BlinkServer.CBOR.IndefiniteLengthData, rhs: BlinkServer.CBOR.IndefiniteLengthData) -> Swift.Bool
}
extension BlinkServer.CBOR.IndefiniteLengthString : Swift.Equatable {
  public static func == (lhs: BlinkServer.CBOR.IndefiniteLengthString, rhs: BlinkServer.CBOR.IndefiniteLengthString) -> Swift.Bool
}
extension BlinkServer.CBOR.Undefined : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension BlinkServer.CBOR.NegativeUInt64 : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension BlinkServer.CBOR.SimpleValue : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension BlinkServer.CBOR.Bignum : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension BlinkServer.CBOR.DecimalFraction : Swift.Encodable where I1 : Swift.Encodable, I2 : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension BlinkServer.CBOR.DecimalFraction : Swift.Decodable where I1 : Swift.Decodable, I2 : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension BlinkServer.CBOR.Bigfloat : Swift.Encodable where I1 : Swift.Encodable, I2 : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension BlinkServer.CBOR.Bigfloat : Swift.Decodable where I1 : Swift.Decodable, I2 : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension BlinkServer.CBOR.IndefiniteLengthArray : Swift.Encodable where Element : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension BlinkServer.CBOR.IndefiniteLengthArray : Swift.Decodable where Element : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension BlinkServer.CBOR.IndefiniteLengthMap : Swift.Encodable where Key : Swift.Encodable, Value : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension BlinkServer.CBOR.IndefiniteLengthMap : Swift.Decodable where Key : Swift.Decodable, Value : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension BlinkServer.CBOR.IndefiniteLengthData : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension BlinkServer.CBOR.IndefiniteLengthString : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension BlinkServer.CBOR.CBOREncoded : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
@frozen public struct AnyEncodable : Swift.Encodable {
  public let value: Any
  public init<T>(_ value: T?)
}
@usableFromInline
internal protocol _AnyEncodable {
  var value: Any { get }
  init<T>(_ value: T?)
}
extension BlinkServer.AnyEncodable : BlinkServer._AnyEncodable {
}
extension BlinkServer._AnyEncodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension BlinkServer.AnyEncodable : Swift.Equatable {
  public static func == (lhs: BlinkServer.AnyEncodable, rhs: BlinkServer.AnyEncodable) -> Swift.Bool
}
extension BlinkServer.AnyEncodable : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension BlinkServer.AnyEncodable : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension BlinkServer.AnyEncodable : Swift.ExpressibleByNilLiteral {
}
extension BlinkServer.AnyEncodable : Swift.ExpressibleByBooleanLiteral {
  public typealias BooleanLiteralType = Swift.Bool
}
extension BlinkServer.AnyEncodable : Swift.ExpressibleByIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int
}
extension BlinkServer.AnyEncodable : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Double
}
extension BlinkServer.AnyEncodable : Swift.ExpressibleByStringLiteral {
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension BlinkServer.AnyEncodable : Swift.ExpressibleByStringInterpolation {
  public typealias StringInterpolation = Swift.DefaultStringInterpolation
}
extension BlinkServer.AnyEncodable : Swift.ExpressibleByArrayLiteral {
  public typealias ArrayLiteralElement = Any
}
extension BlinkServer.AnyEncodable : Swift.ExpressibleByDictionaryLiteral {
  public typealias Key = Swift.AnyHashable
  public typealias Value = Any
}
extension BlinkServer._AnyEncodable {
  public init(nilLiteral _: ())
  public init(booleanLiteral value: Swift.Bool)
  public init(integerLiteral value: Swift.Int)
  public init(floatLiteral value: Swift.Double)
  public init(extendedGraphemeClusterLiteral value: Swift.String)
  public init(stringLiteral value: Swift.String)
  public init(arrayLiteral elements: Any...)
  public init(dictionaryLiteral elements: (Swift.AnyHashable, Any)...)
}
open class CBOREncoder {
  public enum DateEncodingStrategy {
    case rfc3339
    case secondsSince1970
    public static func == (a: BlinkServer.CBOREncoder.DateEncodingStrategy, b: BlinkServer.CBOREncoder.DateEncodingStrategy) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  open var dateEncodingStrategy: BlinkServer.CBOREncoder.DateEncodingStrategy
  open var includeCBORTag: Swift.Bool
  open var keySorter: ((Any, Any) -> Swift.Bool)?
  open var userInfo: [Swift.CodingUserInfoKey : Any]
  public init(dateEncodingStrategy: BlinkServer.CBOREncoder.DateEncodingStrategy = .secondsSince1970, includeCBORTag: Swift.Bool = false, keySorter: ((Any, Any) -> Swift.Bool)? = nil, userInfo: [Swift.CodingUserInfoKey : Any] = [:])
  open func encode<T>(_ value: T) throws -> Foundation.Data where T : Swift.Encodable
  @objc deinit
}
public protocol CBOREncoderProtocol : Swift.Encoder {
  func indefiniteLengthContainerContext<R>(includingSubcontainers: Swift.Bool, _ block: () throws -> R) rethrows -> R
  func definiteLengthContainerContext<R>(includingSubcontainers: Swift.Bool, _ block: () throws -> R) rethrows -> R
}
extension BlinkServer.CBOREncoderProtocol {
  public func indefiniteLengthContainerContext<R>(includingSubcontainers flag: Swift.Bool = false, _ block: () throws -> R) rethrows -> R
  public func definiteLengthContainerContext<R>(includingSubcontainers flag: Swift.Bool = false, _ block: () throws -> R) rethrows -> R
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension BlinkServer.CBOREncoder : Combine.TopLevelEncoder {
  public typealias Output = Foundation.Data
}
extension BlinkServer.Half : Swift.Codable {
  @_transparent public init(from decoder: Swift.Decoder) throws {
        let container = try decoder.singleValueContainer()
        let float = try container.decode(Float.self)

        guard float.isInfinite || float.isNaN || abs(float) <= Float(Half.greatestFiniteMagnitude) else {
            throw DecodingError.dataCorrupted(DecodingError.Context(codingPath: container.codingPath, debugDescription: "Parsed number \(float) does not fit in \(type(of: self))."))
        }

        self.init(float)
    }
  @_transparent public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(Float(self))
    }
}
@objc public enum BlinkLogLevel : Swift.Int {
  case debug = 0
  case verbose = 1
  case info = 5
  case warning = 15
  case error = 20
  public func name() -> Swift.String
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @objc public class BlinkLogLevelName : ObjectiveC.NSObject {
  @objc public class func withLevel(_ logLevel: BlinkServer.BlinkLogLevel) -> Swift.String
  @objc override dynamic public init()
  @objc deinit
}
open class CBORDecoder {
  open var userInfo: [Swift.CodingUserInfoKey : Any]
  public init(userInfo: [Swift.CodingUserInfoKey : Any] = [:])
  open func decode<T>(_ type: T.Type = T.self, from data: Foundation.Data) throws -> T where T : Swift.Decodable
  @objc deinit
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension BlinkServer.CBORDecoder : Combine.TopLevelDecoder {
  public typealias Input = Foundation.Data
}
public enum BlinkKeysError : Swift.Error {
  case privateKeyLengthError(Swift.String)
  case publicKeyLengthError(Swift.String)
}
public struct BlinkKeys {
  public init(devicePrivateKey: Foundation.Data, operationsPublicKey: Foundation.Data) throws
}
@_hasMissingDesignatedInitializers public class BlinkOpenLockerRequest {
  final public let clientInfo: Foundation.Data
  final public let lockerAvailable: Swift.Bool
  final public let lockerToken: Foundation.Data
  final public let keypadCode: Swift.String
  final public let keypadCodePersists: Swift.Bool
  final public let keypadNextToken: Foundation.Data
  final public let keypadNextAvailable: Swift.Bool
  final public let matchToken: Foundation.Data
  final public let matchAvailable: Swift.Bool
  @objc deinit
}
public enum CBOR {
  public struct Undefined {
  }
  public struct NegativeUInt64 : Swift.RawRepresentable {
    public static let max: BlinkServer.CBOR.NegativeUInt64
    public static let min: BlinkServer.CBOR.NegativeUInt64
    public var rawValue: Swift.UInt64
    public init(rawValue: Swift.UInt64)
    public typealias RawValue = Swift.UInt64
  }
  public struct SimpleValue : Swift.RawRepresentable {
    public var rawValue: Swift.UInt8
    public init(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
  }
  public struct Bignum {
    public var isPositive: Swift.Bool
    public var content: Foundation.Data
    public init(isPositive: Swift.Bool, content: Foundation.Data)
  }
  public struct DecimalFraction<I1, I2> where I1 : Swift.FixedWidthInteger, I2 : Swift.FixedWidthInteger {
    public var exponent: I1
    public var mantissa: I2
    public init(exponent: I1, mantissa: I2)
  }
  public struct Bigfloat<I1, I2> where I1 : Swift.FixedWidthInteger, I2 : Swift.FixedWidthInteger {
    public var exponent: I1
    public var mantissa: I2
    public init(exponent: I1, mantissa: I2)
  }
  public struct IndefiniteLengthArray<Element> {
    public var array: [Element]
    public init(wrapping array: [Element] = [])
  }
  public struct IndefiniteLengthMap<Key, Value> where Key : Swift.Hashable {
    public var map: [Key : Value]
    public init(wrapping map: [Key : Value] = [:])
  }
  public struct IndefiniteLengthData {
    public var chunks: [Foundation.Data]
    public init(wrapping chunks: [Foundation.Data] = [])
    public init(wrapping data: Foundation.Data = Data(), chunkSize: Swift.Int = 128)
  }
  public struct IndefiniteLengthString {
    public var chunks: [Foundation.Data]
    @inline(__always) public var stringValue: Swift.String? {
      get
    }
    public init(wrapping chunks: [Swift.String] = [])
    public init(wrapping string: Swift.String = "", chunkSize: Swift.Int = 128)
    public func stringValue(as encoding: Swift.String.Encoding) -> Swift.String?
  }
  public struct CBOREncoded {
    public let encodedData: Foundation.Data
    public init(encodedData: Foundation.Data)
  }
}
@frozen public struct AnyCodable : Swift.Codable {
  public let value: Any
  public init<T>(_ value: T?)
}
extension BlinkServer.AnyCodable : BlinkServer._AnyEncodable, BlinkServer._AnyDecodable {
}
extension BlinkServer.AnyCodable : Swift.Equatable {
  public static func == (lhs: BlinkServer.AnyCodable, rhs: BlinkServer.AnyCodable) -> Swift.Bool
}
extension BlinkServer.AnyCodable : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension BlinkServer.AnyCodable : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension BlinkServer.AnyCodable : Swift.ExpressibleByNilLiteral {
}
extension BlinkServer.AnyCodable : Swift.ExpressibleByBooleanLiteral {
  public typealias BooleanLiteralType = Swift.Bool
}
extension BlinkServer.AnyCodable : Swift.ExpressibleByIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int
}
extension BlinkServer.AnyCodable : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Double
}
extension BlinkServer.AnyCodable : Swift.ExpressibleByStringLiteral {
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension BlinkServer.AnyCodable : Swift.ExpressibleByArrayLiteral {
  public typealias ArrayLiteralElement = Any
}
extension BlinkServer.AnyCodable : Swift.ExpressibleByDictionaryLiteral {
  public typealias Key = Swift.AnyHashable
  public typealias Value = Any
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class Packet : BlinkServer.BlinkStruct {
  @objc deinit
}
extension BlinkServer.Half : Swift.Sendable {}
extension BlinkServer.CBOREncoder.DateEncodingStrategy : Swift.Equatable {}
extension BlinkServer.CBOREncoder.DateEncodingStrategy : Swift.Hashable {}
extension BlinkServer.BlinkLogLevel : Swift.Equatable {}
extension BlinkServer.BlinkLogLevel : Swift.Hashable {}
extension BlinkServer.BlinkLogLevel : Swift.RawRepresentable {}
