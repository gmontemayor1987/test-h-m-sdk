// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.6.1 (swiftlang-5.6.0.323.66 clang-1316.0.20.12)
// swift-module-flags: -target arm64-apple-ios14.4-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name HarborLockersSDK
import CoreGraphics.CGBase
import Combine
import CommonCrypto
import Compression
import CoreBluetooth
import CoreFoundation
import CoreGraphics
import Dispatch
import Foundation
@_exported import HarborLockersSDK
import Swift
import UIKit
import _Concurrency
@_hasMissingDesignatedInitializers @objc public class Tower : ObjectiveC.NSObject {
  @objc final public let firmwareVersion: Swift.String!
  @objc public var towerId: Foundation.Data!
  @objc public var towerName: Swift.String!
  @objc public func peripheralUUID() -> Swift.String
  @objc deinit
}
open class CBORDecoder {
  open var userInfo: [Swift.CodingUserInfoKey : Any]
  public init()
  open func decode<T>(_ type: T.Type, from data: Foundation.Data) throws -> T where T : Swift.Decodable
  @objc deinit
}
extension HarborLockersSDK.CBORDecoder : Combine.TopLevelDecoder {
  public typealias Input = Foundation.Data
}
@frozen public struct AnyDecodable : Swift.Decodable {
  public let value: Any
  public init<T>(_ value: T?)
}
@usableFromInline
internal protocol _AnyDecodable {
  var value: Any { get }
  init<T>(_ value: T?)
}
extension HarborLockersSDK.AnyDecodable : HarborLockersSDK._AnyDecodable {
}
extension HarborLockersSDK._AnyDecodable {
  public init(from decoder: Swift.Decoder) throws
}
extension HarborLockersSDK.AnyDecodable : Swift.Equatable {
  public static func == (lhs: HarborLockersSDK.AnyDecodable, rhs: HarborLockersSDK.AnyDecodable) -> Swift.Bool
}
extension HarborLockersSDK.AnyDecodable : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension HarborLockersSDK.AnyDecodable : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Foundation.Data {
  public func cborHexStringFromJSON() -> Swift.String
  public func hexString() -> Swift.String
  public static func randomCryptoBytes(_ count: Swift.Int) throws -> Foundation.Data
  public init?(hexString: Swift.String)
}
extension Foundation.NSData {
  @objc dynamic public func initWith(hexString: Swift.String) -> Foundation.NSData?
  @objc dynamic public func cborHexStringFromJSON() -> Swift.String
  @objc dynamic public func hexString() -> Swift.String
  @objc public static func randomCryptoBytes(_ count: Swift.Int) -> Foundation.NSData?
}
extension HarborLockersSDK.CBOR.NegativeUInt64 : Swift.Equatable {
  public static func == (lhs: HarborLockersSDK.CBOR.NegativeUInt64, rhs: HarborLockersSDK.CBOR.NegativeUInt64) -> Swift.Bool
}
extension HarborLockersSDK.CBOR.SimpleValue : Swift.Equatable {
  public static func == (lhs: HarborLockersSDK.CBOR.SimpleValue, rhs: HarborLockersSDK.CBOR.SimpleValue) -> Swift.Bool
}
extension HarborLockersSDK.CBOR.Bignum : Swift.Equatable {
  public static func == (lhs: HarborLockersSDK.CBOR.Bignum, rhs: HarborLockersSDK.CBOR.Bignum) -> Swift.Bool
}
extension HarborLockersSDK.CBOR.DecimalFraction : Swift.Equatable {
  public static func == (lhs: HarborLockersSDK.CBOR.DecimalFraction<I1, I2>, rhs: HarborLockersSDK.CBOR.DecimalFraction<I1, I2>) -> Swift.Bool
}
extension HarborLockersSDK.CBOR.Bigfloat : Swift.Equatable {
  public static func == (lhs: HarborLockersSDK.CBOR.Bigfloat<I1, I2>, rhs: HarborLockersSDK.CBOR.Bigfloat<I1, I2>) -> Swift.Bool
}
extension HarborLockersSDK.CBOR.IndefiniteLengthArray : Swift.Equatable where Element : Swift.Equatable {
  public static func == (lhs: HarborLockersSDK.CBOR.IndefiniteLengthArray<Element>, rhs: HarborLockersSDK.CBOR.IndefiniteLengthArray<Element>) -> Swift.Bool
}
extension HarborLockersSDK.CBOR.IndefiniteLengthMap : Swift.Equatable where Value : Swift.Equatable {
  public static func == (lhs: HarborLockersSDK.CBOR.IndefiniteLengthMap<Key, Value>, rhs: HarborLockersSDK.CBOR.IndefiniteLengthMap<Key, Value>) -> Swift.Bool
}
extension HarborLockersSDK.CBOR.IndefiniteLengthData : Swift.Equatable {
  public static func == (lhs: HarborLockersSDK.CBOR.IndefiniteLengthData, rhs: HarborLockersSDK.CBOR.IndefiniteLengthData) -> Swift.Bool
}
extension HarborLockersSDK.CBOR.IndefiniteLengthString : Swift.Equatable {
  public static func == (lhs: HarborLockersSDK.CBOR.IndefiniteLengthString, rhs: HarborLockersSDK.CBOR.IndefiniteLengthString) -> Swift.Bool
}
public typealias BLEConnectionResult = (_ result: Swift.String?, _ error: Swift.Error?) -> Swift.Void
public typealias BLEResponseHandler = (_ responseData: Foundation.Data?, _ error: Swift.Error?) -> Swift.Void
public typealias BLETowersDiscoveredHandler = (_ peripherals: [HarborLockersSDK.Tower]) -> Swift.Void
public typealias SyncCompletionHandler = (_ success: Swift.Bool, _ error: Foundation.NSError?) -> Swift.Void
public enum HarborLogLevel : Swift.Int {
  case debug
  case verbose
  case info
  case warning
  case error
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct CBOR {
  public struct Undefined {
  }
  public struct NegativeUInt64 : Swift.RawRepresentable {
    public var rawValue: Swift.UInt64
    public init(rawValue: Swift.UInt64)
    public typealias RawValue = Swift.UInt64
  }
  public struct SimpleValue : Swift.RawRepresentable {
    public var rawValue: Swift.UInt8
    public init(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
  }
  public struct Bignum {
  }
  public struct DecimalFraction<I1, I2> where I1 : Swift.FixedWidthInteger, I2 : Swift.FixedWidthInteger {
  }
  public struct Bigfloat<I1, I2> where I1 : Swift.FixedWidthInteger, I2 : Swift.FixedWidthInteger {
  }
  public struct IndefiniteLengthArray<Element> {
    public var array: [Element]
    public init(wrapping array: [Element] = [])
  }
  public struct IndefiniteLengthMap<Key, Value> where Key : Swift.Hashable {
    public var map: [Key : Value]
    public init(wrapping map: [Key : Value] = [:])
  }
  public struct IndefiniteLengthData {
    public var chunks: [Foundation.Data]
    public init(wrapping chunks: [Foundation.Data] = [])
    public init(wrapping data: Foundation.Data = Data(), chunkSize: Swift.Int = 128)
  }
  public struct IndefiniteLengthString {
    public var chunks: [Foundation.Data]
    public var stringValue: Swift.String? {
      get
    }
    public init(wrapping chunks: [Swift.String] = [])
    public init(wrapping string: Swift.String = "", chunkSize: Swift.Int = 128)
  }
  public struct CBOREncoded {
    public let encodedData: Foundation.Data
    public init(encodedData: Foundation.Data)
  }
}
@objc public enum SessionPermission : Swift.Int {
  case Sync, LockerPickup, LockerDelivery, Owner, Technician, Developer
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@frozen public struct Half {
  public var _value: HarborLockersSDK.half_t
  @_transparent public init() {
        self._value = _half_zero()
    }
  @_transparent public init(_ _value: HarborLockersSDK.half_t) {
        self._value = _value
    }
}
extension HarborLockersSDK.Half {
  @inlinable public var bitPattern: Swift.UInt16 {
    get {
        return _half_to_raw(_value)
    }
  }
  @inlinable public init(bitPattern: Swift.UInt16) {
        self._value = _half_from_raw(bitPattern)
    }
  @inlinable public init(nan payload: Swift.UInt16, signaling: Swift.Bool) {
        precondition(payload < (Half.quietNaNMask &>> 1), "NaN payload is not encodable.")

        var significand = payload
        significand |= Half.quietNaNMask &>> (signaling ? 1 : 0)

        self.init(sign: .plus, exponentBitPattern: Half.infinityExponent, significandBitPattern: significand)
    }
}
extension HarborLockersSDK.Half : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension HarborLockersSDK.Half : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension HarborLockersSDK.Half : Swift.TextOutputStreamable {
  public func write<Target>(to target: inout Target) where Target : Swift.TextOutputStream
}
extension HarborLockersSDK.Half {
  @inlinable @inline(__always) internal static var significandMask: Swift.UInt16 {
    get {
        return 1 &<< UInt16(significandBitCount) - 1
    }
  }
  @inlinable @inline(__always) internal static var infinityExponent: Swift.UInt {
    get {
        return 1 &<< UInt(exponentBitCount) - 1
    }
  }
  @inlinable @inline(__always) internal static var exponentBias: Swift.UInt {
    get {
        return infinityExponent &>> 1
    }
  }
  @inlinable @inline(__always) internal static var quietNaNMask: Swift.UInt16 {
    get {
        return 1 &<< UInt16(significandBitCount - 1)
    }
  }
}
extension HarborLockersSDK.Half : Swift.BinaryFloatingPoint {
  @inlinable public static var exponentBitCount: Swift.Int {
    get {
        return 5
    }
  }
  @inlinable public static var significandBitCount: Swift.Int {
    get {
        return 10
    }
  }
  @inlinable public var exponentBitPattern: Swift.UInt {
    get {
        return UInt(bitPattern &>> UInt16(Half.significandBitCount)) & Half.infinityExponent
    }
  }
  @inlinable public var significandBitPattern: Swift.UInt16 {
    get {
        return bitPattern & Half.significandMask
    }
  }
  @inlinable public init(sign: Swift.FloatingPointSign, exponentBitPattern: Swift.UInt, significandBitPattern: Swift.UInt16) {
        let signBits: UInt16 = (sign == .minus ? 1 : 0) &<< (Half.exponentBitCount + Half.significandBitCount)
        let exponentBits = UInt16((exponentBitPattern & Half.infinityExponent) &<< Half.significandBitCount)
        let significandBits = significandBitPattern & Half.significandMask

        self.init(bitPattern: signBits | exponentBits | significandBits)
    }
  @inlinable @inline(__always) public init(_ other: Swift.Float) {
        if other.isInfinite {
            let infinity = Half.infinity
            self = Half(sign: other.sign, exponentBitPattern: infinity.exponentBitPattern, significandBitPattern: infinity.significandBitPattern)
        } else if other.isNaN {
            if other.isSignalingNaN {
                self = .signalingNaN
            } else {
                self = .nan
            }
        } else {
            _value = _half_from(other)
        }
    }
  @inlinable @inline(__always) public init(_ other: Swift.Double) {
        if other.isInfinite {
            let infinity = Half.infinity
            self = Half(sign: other.sign, exponentBitPattern: infinity.exponentBitPattern, significandBitPattern: infinity.significandBitPattern)
        } else if other.isNaN {
            if other.isSignalingNaN {
                self = .signalingNaN
            } else {
                self = .nan
            }
        } else {
            _value = _half_from(other)
        }
    }
  @inlinable @inline(__always) public init(_ other: CoreGraphics.CGFloat) {
        self.init(other.native)
    }
  @inlinable @inline(__always) public init<Source>(_ value: Source) where Source : Swift.BinaryFloatingPoint {
        if let half = value as? Half {
            self.init(half._value)
        } else {
            self.init(Float(value))
        }
    }
  @inlinable public init?<Source>(exactly value: Source) where Source : Swift.BinaryFloatingPoint {
        self.init(value)

        if isInfinite || value.isInfinite {
            if value.isInfinite && (!isInfinite || sign != value.sign) {
                // If source is infinite but this isn't or this is but with a different sign
                return nil
            } else if isInfinite && !value.isInfinite {
                // If source isn't infinite but this is
                return nil
            }
        } else if isNaN || value.isNaN {
            if value.isNaN && (!isNaN || isSignalingNaN != value.isSignalingNaN) {
                // If source is NaN but this isn't or this is but one is signaling while the other isn't
                return nil
            } else if isNaN && !value.isNaN {
                // If source isn't NaN but this is
                return nil
            }
        } else if Source(self) != value {
            // If casting half back to source isn't equal to original source
            return nil
        }
    }
  @inlinable public var binade: HarborLockersSDK.Half {
    get {
        guard isFinite else { return .nan }

        if isSubnormal {
            let bitPattern = (self * 0x1p10).bitPattern & (-Half.infinity).bitPattern
            return Half(bitPattern: bitPattern) * .ulpOfOne
        }

        return Half(bitPattern: bitPattern & (-Half.infinity).bitPattern)
    }
  }
  @inlinable public var significandWidth: Swift.Int {
    get {
        let trailingZeroBits = significandBitPattern.trailingZeroBitCount
        if isNormal {
            guard significandBitPattern != 0 else { return 0 }
            return Half.significandBitCount &- trailingZeroBits
        }
        if isSubnormal {
            let leadingZeroBits = significandBitPattern.leadingZeroBitCount
            return UInt16.bitWidth &- (trailingZeroBits &+ leadingZeroBits &+ 1)
        }
        return -1
    }
  }
  public typealias RawExponent = Swift.UInt
  public typealias RawSignificand = Swift.UInt16
}
extension HarborLockersSDK.Half : Swift.ExpressibleByFloatLiteral {
  @_transparent public init(floatLiteral value: Swift.Float) {
        self.init(value)
    }
  public typealias FloatLiteralType = Swift.Float
}
extension HarborLockersSDK.Half : Swift.FloatingPoint {
  @inlinable public init(sign: Swift.FloatingPointSign, exponent: Swift.Int, significand: HarborLockersSDK.Half) {
        var result = significand
        if sign == .minus { result = -result }

        if significand.isFinite && !significand.isZero {
            var clamped = exponent
            let leastNormalExponent = 1 - Int(Half.exponentBias)
            let greatestFiniteExponent = Int(Half.exponentBias)

            if clamped < leastNormalExponent {
                clamped = max(clamped, 3 * leastNormalExponent)

                while clamped < leastNormalExponent {
                    result *= Half.leastNormalMagnitude
                    clamped -= leastNormalExponent
                }
            } else if clamped > greatestFiniteExponent {
                let step = Half(sign: .plus, exponentBitPattern: Half.infinityExponent - 1, significandBitPattern: 0)
                clamped = min(clamped, 3 * greatestFiniteExponent)

                while clamped > greatestFiniteExponent {
                    result *= step
                    clamped -= greatestFiniteExponent
                }
            }

            let scale = Half(sign: .plus, exponentBitPattern: UInt(Int(Half.exponentBias) + clamped), significandBitPattern: 0)
            result *= scale
        }

        self = result
    }
  @_transparent public init(_ value: Swift.Int) {
        _value = _half_from(value)
    }
  @inlinable @inline(__always) public init<Source>(_ value: Source) where Source : Swift.BinaryInteger {
        if value.bitWidth <= MemoryLayout<Int>.size * 8 {
            if Source.isSigned {
                let asInt = Int(truncatingIfNeeded: value)
                self.init(_half_from(asInt))
            } else {
                let asUInt = UInt(truncatingIfNeeded: value)
                self.init(_half_from(asUInt))
            }
        } else {
            self.init(Float(value))
        }
    }
  @inlinable public var exponent: Swift.Int {
    get {
        if !isFinite { return .max }
        if isZero { return .min }

        let provisional = Int(exponentBitPattern) - Int(Half.exponentBias)
        if isNormal { return provisional }

        let shift = Half.significandBitCount - Int(significandBitPattern._binaryLogarithm())
        return provisional + 1 - shift
    }
  }
  @inlinable public var isCanonical: Swift.Bool {
    get {

        return true
    }
  }
  @inlinable @inline(__always) public var isFinite: Swift.Bool {
    get {
        return exponentBitPattern < Half.infinityExponent
    }
  }
  @inlinable @inline(__always) public var isInfinite: Swift.Bool {
    get {
        return !isFinite && significandBitPattern == 0
    }
  }
  @inlinable @inline(__always) public var isNaN: Swift.Bool {
    get {
        return !isFinite && significandBitPattern != 0
    }
  }
  @inlinable @inline(__always) public var isNormal: Swift.Bool {
    get {
        return exponentBitPattern > 0 && isFinite
    }
  }
  @inlinable @inline(__always) public var isSignalingNaN: Swift.Bool {
    get {
        return isNaN && (significandBitPattern & Half.quietNaNMask) == 0
    }
  }
  @inlinable @inline(__always) public var isSubnormal: Swift.Bool {
    get {
        return exponentBitPattern == 0 && significandBitPattern != 0
    }
  }
  @inlinable @inline(__always) public var isZero: Swift.Bool {
    get {
        return exponentBitPattern == 0 && significandBitPattern == 0
    }
  }
  @inlinable public var nextUp: HarborLockersSDK.Half {
    get {
        let next = self + 0


        if next < .infinity {
            let increment = Int16(bitPattern: next.bitPattern) &>> 15 | 1
            let bitPattern = next.bitPattern &+ UInt16(bitPattern: increment)
            return Half(bitPattern: bitPattern)
        }

        return next
    }
  }
  @inlinable public var sign: Swift.FloatingPointSign {
    get {
        let shift = Half.significandBitCount + Half.exponentBitCount
        //swiftlint:disable force_unwrapping
        return FloatingPointSign(rawValue: Int(bitPattern &>> UInt16(shift)))!
        //swiftlint:enable force_unwrapping
    }
  }
  @inlinable public var significand: HarborLockersSDK.Half {
    get {
        if isNaN { return self }
        if isNormal {
            return Half(sign: .plus, exponentBitPattern: Half.exponentBias, significandBitPattern: significandBitPattern)
        }

        if isSubnormal {
            let shift = Half.significandBitCount - Int(significandBitPattern._binaryLogarithm())
            return Half(sign: .plus, exponentBitPattern: Half.exponentBias, significandBitPattern: significandBitPattern &<< shift)
        }

        return Half(sign: .plus, exponentBitPattern: exponentBitPattern, significandBitPattern: 0)
    }
  }
  @inlinable public var ulp: HarborLockersSDK.Half {
    get {
        guard isFinite else { return .nan }
        if isNormal {
            let bitPattern = self.bitPattern & Half.infinity.bitPattern
            return Half(bitPattern: bitPattern) * .ulpOfOne
        }

        return .leastNormalMagnitude * .ulpOfOne
    }
  }
  @inlinable public static var greatestFiniteMagnitude: HarborLockersSDK.Half {
    get {
        return Half(bitPattern: 0x7BFF)
    }
  }
  @inlinable public static var infinity: HarborLockersSDK.Half {
    get {
        return Half(bitPattern: 0x7C00)
    }
  }
  @inlinable public static var leastNonzeroMagnitude: HarborLockersSDK.Half {
    get {
        return Half(sign: .plus, exponentBitPattern: 0, significandBitPattern: 1)
    }
  }
  @inlinable public static var leastNormalMagnitude: HarborLockersSDK.Half {
    get {
        return Half(sign: .plus, exponentBitPattern: 1, significandBitPattern: 0)
    }
  }
  @inlinable public static var nan: HarborLockersSDK.Half {
    get {
        return Half(_half_nan())
    }
  }
  @inlinable public static var pi: HarborLockersSDK.Half {
    get {
        return Half(_half_pi())
    }
  }
  @inlinable public static var signalingNaN: HarborLockersSDK.Half {
    get {
        return Half(nan: 0, signaling: true)
    }
  }
  @inlinable public static var ulpOfOne: HarborLockersSDK.Half {
    get {
        return Half(_half_epsilon())
    }
  }
  @_transparent public mutating func addProduct(_ lhs: HarborLockersSDK.Half, _ rhs: HarborLockersSDK.Half) {
        _value = _half_fma(_value, lhs._value, rhs._value)
    }
  @inlinable @inline(__always) public mutating func formRemainder(dividingBy other: HarborLockersSDK.Half) {
        self = Half(Float(self).remainder(dividingBy: Float(other)))
    }
  @_transparent public mutating func formSquareRoot() {
        _value = _half_sqrt(_value)
    }
  @inlinable @inline(__always) public mutating func formTruncatingRemainder(dividingBy other: HarborLockersSDK.Half) {
        self = Half(Float(self).truncatingRemainder(dividingBy: Float(other)))
    }
  @_transparent public func isEqual(to other: HarborLockersSDK.Half) -> Swift.Bool {
        return Bool(_half_equal(self._value, other._value))
    }
  @_transparent public func isLess(than other: HarborLockersSDK.Half) -> Swift.Bool {
        return Bool(_half_lt(self._value, other._value))
    }
  @_transparent public func isLessThanOrEqualTo(_ other: HarborLockersSDK.Half) -> Swift.Bool {
        return Bool(_half_lte(self._value, other._value))
    }
  @_transparent public mutating func round(_ rule: Swift.FloatingPointRoundingRule) {
        self = Half(Float(self).rounded(rule))
    }
  @_transparent public static func / (lhs: HarborLockersSDK.Half, rhs: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
        return Half(_half_div(lhs._value, rhs._value))
    }
  @_transparent public static func /= (lhs: inout HarborLockersSDK.Half, rhs: HarborLockersSDK.Half) {
        lhs._value = _half_div(lhs._value, rhs._value)
    }
  public typealias Exponent = Swift.Int
}
extension HarborLockersSDK.Half : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
        var value = self
        if isZero {
            value = 0 // to reconcile -0.0 and +0.0
        }

        hasher.combine(value.bitPattern)
    }
  public var hashValue: Swift.Int {
    get
  }
}
extension HarborLockersSDK.Half : Swift.Strideable {
  @_transparent public func distance(to other: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
        return other - self
    }
  @_transparent public func advanced(by amount: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
        return self + amount
    }
  public typealias Stride = HarborLockersSDK.Half
}
extension HarborLockersSDK.Half : Swift.SignedNumeric {
  @_transparent public mutating func negate() {
        _value = _half_neg(_value)
    }
  @_transparent prefix public static func - (value: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
        return Half(_half_neg(value._value))
    }
}
extension HarborLockersSDK.Half : Swift.Numeric {
  @inlinable @inline(__always) public var magnitude: HarborLockersSDK.Half {
    get {
        return Half(_half_abs(_value))
    }
  }
  @inlinable @inline(__always) public init?<Source>(exactly value: Source) where Source : Swift.BinaryInteger {
        self.init(value)

        if isInfinite || isNaN || Source(self) != value {
            return nil
        }
    }
  @_transparent public static func * (lhs: HarborLockersSDK.Half, rhs: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
        return Half(_half_mul(lhs._value, rhs._value))
    }
  @_transparent public static func *= (lhs: inout HarborLockersSDK.Half, rhs: HarborLockersSDK.Half) {
        lhs._value = _half_mul(lhs._value, rhs._value)
    }
  public typealias Magnitude = HarborLockersSDK.Half
}
extension HarborLockersSDK.Half : Swift.ExpressibleByIntegerLiteral {
  @_transparent public init(integerLiteral value: Swift.Int64) {
        self = Half(value)
    }
  public typealias IntegerLiteralType = Swift.Int64
}
extension HarborLockersSDK.Half : Swift.AdditiveArithmetic {
  @_transparent public static func + (lhs: HarborLockersSDK.Half, rhs: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
        return Half(_half_add(lhs._value, rhs._value))
    }
  @_transparent public static func += (lhs: inout HarborLockersSDK.Half, rhs: HarborLockersSDK.Half) {
        lhs._value = _half_add(lhs._value, rhs._value)
    }
  @_transparent public static func - (lhs: HarborLockersSDK.Half, rhs: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
        return Half(_half_sub(lhs._value, rhs._value))
    }
  @_transparent public static func -= (lhs: inout HarborLockersSDK.Half, rhs: HarborLockersSDK.Half) {
        lhs._value = _half_sub(lhs._value, rhs._value)
    }
}
extension HarborLockersSDK.Half : Swift.CustomReflectable {
  @_transparent public var customMirror: Swift.Mirror {
    @_transparent get {
        return Mirror(reflecting: Float(self))
    }
  }
}
extension HarborLockersSDK.Half : Swift.CustomPlaygroundDisplayConvertible {
  @_transparent public var playgroundDescription: Any {
    @_transparent get {
        return Float(self)
    }
  }
}
@_transparent public func acos(_ value: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(acos(Float(value)))
}
@_transparent public func acosh(_ value: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(acosh(Float(value)))
}
@_transparent public func asin(_ value: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(asin(Float(value)))
}
@_transparent public func asinh(_ value: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(asinh(Float(value)))
}
@_transparent public func atan(_ value: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(atan(Float(value)))
}
@_transparent public func atanh(_ value: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(atanh(Float(value)))
}
@_transparent public func cbrt(_ value: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(cbrt(Float(value)))
}
@_transparent public func cos(_ value: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(cos(Float(value)))
}
@_transparent public func cosh(_ value: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(cosh(Float(value)))
}
@_transparent public func erf(_ value: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(erf(Float(value)))
}
@_transparent public func erfc(_ value: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(erfc(Float(value)))
}
@_transparent public func exp(_ value: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(exp(Float(value)))
}
@_transparent public func exp2(_ value: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(exp2(Float(value)))
}
@_transparent public func expm1(_ value: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(expm1(Float(value)))
}
@_transparent public func log(_ value: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(log(Float(value)))
}
@_transparent public func log10(_ value: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(log10(Float(value)))
}
@_transparent public func log1p(_ value: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(log1p(Float(value)))
}
@_transparent public func log2(_ value: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(log2(Float(value)))
}
@_transparent public func logb(_ value: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(logb(Float(value)))
}
@_transparent public func nearbyint(_ value: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(nearbyint(Float(value)))
}
@_transparent public func rint(_ value: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(rint(Float(value)))
}
@_transparent public func sin(_ value: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(sin(Float(value)))
}
@_transparent public func sinh(_ value: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(sinh(Float(value)))
}
@_transparent public func tan(_ value: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(tan(Float(value)))
}
@_transparent public func tanh(_ value: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(tanh(Float(value)))
}
@_transparent public func tgamma(_ value: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(tgamma(Float(value)))
}
@_transparent public func atan2(_ lhs: HarborLockersSDK.Half, _ rhs: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(atan2(Float(lhs), Float(rhs)))
}
@_transparent public func copysign(_ lhs: HarborLockersSDK.Half, _ rhs: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(copysign(Float(lhs), Float(rhs)))
}
@_transparent public func fdim(_ lhs: HarborLockersSDK.Half, _ rhs: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(fdim(Float(lhs), Float(rhs)))
}
@_transparent public func fmax(_ lhs: HarborLockersSDK.Half, _ rhs: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(fmax(Float(lhs), Float(rhs)))
}
@_transparent public func fmin(_ lhs: HarborLockersSDK.Half, _ rhs: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(fmin(Float(lhs), Float(rhs)))
}
@_transparent public func hypot(_ lhs: HarborLockersSDK.Half, _ rhs: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(hypot(Float(lhs), Float(rhs)))
}
@_transparent public func nextafter(_ lhs: HarborLockersSDK.Half, _ rhs: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(nextafter(Float(lhs), Float(rhs)))
}
@_transparent public func pow(_ lhs: HarborLockersSDK.Half, _ rhs: HarborLockersSDK.Half) -> HarborLockersSDK.Half {
    return Half(pow(Float(lhs), Float(rhs)))
}
@_transparent public func lgamma(_ value: HarborLockersSDK.Half) -> (HarborLockersSDK.Half, Swift.Int) {
    let result = lgamma(Float(value))
    return (Half(result.0), result.1)
}
@_transparent public func remquo(_ lhs: HarborLockersSDK.Half, _ rhs: HarborLockersSDK.Half) -> (HarborLockersSDK.Half, Swift.Int) {
    let result = remquo(Float(lhs), Float(rhs))
    return (Half(result.0), result.1)
}
open class CBOREncoder {
  public enum DateEncodingStrategy {
    case rfc3339
    case secondsSince1970
    public static func == (a: HarborLockersSDK.CBOREncoder.DateEncodingStrategy, b: HarborLockersSDK.CBOREncoder.DateEncodingStrategy) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  open var dateEncodingStrategy: HarborLockersSDK.CBOREncoder.DateEncodingStrategy
  open var includeCBORTag: Swift.Bool
  open var keySorter: ((Any, Any) -> Swift.Bool)?
  open var userInfo: [Swift.CodingUserInfoKey : Any]
  public init()
  open func encode<T>(_ value: T) throws -> Foundation.Data where T : Swift.Encodable
  @objc deinit
}
public protocol CBOREncoderProtocol : Swift.Encoder {
  func indefiniteLengthContainerContext<R>(includingSubcontainers: Swift.Bool, _ block: () throws -> R) rethrows -> R
  func definiteLengthContainerContext<R>(includingSubcontainers: Swift.Bool, _ block: () throws -> R) rethrows -> R
}
extension HarborLockersSDK.CBOREncoderProtocol {
  public func indefiniteLengthContainerContext<R>(includingSubcontainers flag: Swift.Bool = false, _ block: () throws -> R) rethrows -> R
  public func definiteLengthContainerContext<R>(includingSubcontainers flag: Swift.Bool = false, _ block: () throws -> R) rethrows -> R
}
extension HarborLockersSDK.CBOREncoder : Combine.TopLevelEncoder {
  public typealias Output = Foundation.Data
}
public typealias CommandSentResponseHandler = (_ success: Swift.Bool, _ error: Foundation.NSError?) -> Swift.Void
@objc public protocol HarborSDKDelegate {
  @objc func harborDidDiscoverTowers(_ towers: [HarborLockersSDK.Tower])
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc public class HarborSDK : ObjectiveC.NSObject {
  @objc public static let shared: HarborLockersSDK.HarborSDK
  @objc public var delegate: HarborLockersSDK.HarborSDKDelegate!
  public var loggerDelegate: HarborLockersSDK.HarborLoggerDelegate?
  public var logLevel: HarborLockersSDK.HarborLogLevel
  @objc public func isSyncing() -> Swift.Bool
  @objc public func setBaseURL(_ baseURL: Swift.String)
  @objc public func loginWithEmail(_ email: Swift.String, password: Swift.String, completion: @escaping HarborLockersSDK.APIResponseWithStatusCode)
  @objc public func setAccessToken(_ token: Swift.String)
  @objc public func setEnvironment(_ environment: HarborLockersSDK.Environment)
  @objc public func downloadTowerConfiguration(completion: @escaping (_ success: Swift.Bool) -> Swift.Void)
  @objc public func startTowerDiscovery()
  @objc public func connectToTower(_ tower: HarborLockersSDK.Tower, completion: @escaping HarborLockersSDK.BLEConnectionResult)
  @objc deinit
}
extension HarborLockersSDK.HarborSDK {
  @objc dynamic public func sync(completionHandler: @escaping HarborLockersSDK.SyncCompletionHandler)
  @objc dynamic public func establishSession(towerId: Foundation.Data?, duration: Swift.Int = 600, sessionPermissions: HarborLockersSDK.SessionPermission, completionHandler: @escaping HarborLockersSDK.CommandSentResponseHandler)
  @objc dynamic public func getSessionRequest(towerId: Foundation.Data?, duration: Swift.Int = 3600, sessionPermissions: HarborLockersSDK.SessionPermission, completionHandler: @escaping HarborLockersSDK.RequestTowerSessionAPIResponse)
  @objc dynamic public func sendRequestSession(payloadAuth: Foundation.Data, payload: Foundation.Data, sessionSeed: Foundation.Data, completionHandler: @escaping HarborLockersSDK.CommandSentResponseHandler)
  @objc dynamic public func sendTerminateSession(errorCode: Swift.Int, errorMessage: Swift.String?, disconnectAfterSessionTerminated: Swift.Bool = true, completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
  @objc dynamic public func sendInstallKey(keyId: Swift.Int, keyRotation: Swift.Int, keyExpires: Foundation.Date, keyData: Foundation.Data, keyLocator: Swift.String, completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
  @objc dynamic public func sendSunsetKey(keyId: Swift.Int, keyRotation: Swift.Int, completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
  @objc dynamic public func sendRevokeKey(keyId: Swift.Int, keyRotation: Swift.Int, completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
  #warning("We might want to remove some of the sync events from the public interface as sync must be handled entirely by the SDK.")
  @objc dynamic public func sendRequestSyncStatus(completionHandler: @escaping (_ syncEventStart: Swift.Int, _ syncEventCount: Swift.Int, _ syncCommandStart: Swift.Int, _ error: Foundation.NSError?) -> Swift.Void)
  @objc dynamic public func sendSyncPull(syncEventStart: Swift.UInt32, completionHandler: @escaping (_ firstEventId: Swift.Int, _ syncEventCount: Swift.Int, _ payload: Foundation.Data, _ payloadAuth: Foundation.Data, _ error: Foundation.NSError?) -> Swift.Void)
  @objc dynamic public func sendSyncPush(payload: Foundation.Data, payloadAuth: Foundation.Data, completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
  @objc dynamic public func sendMarkSeenEvents(syncEventStart: Swift.UInt32, completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
  @objc dynamic public func sendResetEventCounter(syncEventStart: Swift.UInt32, completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
  @objc dynamic public func sendResetCommandCounter(syncCommandStart: Swift.UInt32, completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
  @objc dynamic public func sendAddClientEvent(clientInfo: Foundation.Data, completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
  @objc dynamic public func sendFindAvailableLockers(completionHandler: @escaping (_ availableLockers: [Swift.Int : Swift.Int]?, _ error: Foundation.NSError?) -> Swift.Void)
  @objc dynamic public func sendFindLockersWithToken(matchAvailable: Swift.Bool, matchToken: Foundation.Data, completionHandler: @escaping (_ availableLockers: [Swift.Int : Swift.Int]?, _ error: Foundation.NSError?) -> Swift.Void)
  @objc dynamic public func sendOpenLockerWithToken(payload: Foundation.Data, payloadAuth: Foundation.Data, completionHandler: @escaping (_ lockerId: Swift.Int, _ error: Foundation.NSError?) -> Swift.Void)
  @objc dynamic public func sendOpenAvailableLocker(matchLockerType: Swift.Int, matchAvailable: Swift.Bool, matchToken: Foundation.Data?, lockerToken: Foundation.Data, lockerAvailable: Swift.Bool, clientInfo: Foundation.Data, completionHandler: @escaping (_ lockerId: Swift.Int, _ error: Foundation.NSError?) -> Swift.Void)
  @objc dynamic public func sendReopenLocker(completionHandler: @escaping (_ lockerId: Swift.Int, _ error: Foundation.NSError?) -> Swift.Void)
  @objc dynamic public func sendCheckLockerDoor(completionHandler: @escaping (_ doorOpen: Swift.Bool, _ error: Foundation.NSError?) -> Swift.Void)
  @objc dynamic public func sendRevertLockerState(clientInfo: Foundation.Data, completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
  @objc dynamic public func sendSetKeypadCode(keypadCode: Swift.String, keypadCodePersists: Swift.Bool, keypadNextToken: Foundation.Data, keypadNextAvailable: Swift.Bool, completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
  @objc dynamic public func sendTapLocker(lockerTapIntervalMS: Swift.Int, lockerTapCount: Swift.Int, completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
  @objc dynamic public func sendCheckAllLockerDoors(completionHandler: @escaping (_ lockerDoorsOpen: Foundation.Data?, _ error: Foundation.NSError?) -> Swift.Void)
  @objc dynamic public func sendGetDeviceInfo(completionHandler: @escaping (_ towerId: Foundation.Data, _ towerName: Swift.String, _ deviceModel: Swift.String, _ deviceSerial: Swift.String, _ towerSerial: Swift.String, _ firmwareVersion: Swift.String, _ mainboardId: Swift.Int, _ shield1Id: Swift.Int, _ shield2Id: Swift.Int, _ solenoidDelay: Swift.Int, _ error: Foundation.NSError?) -> Swift.Void)
  @objc dynamic public func sendGetKeyInfo(keyId: Swift.Int, keyRotation: Swift.Int, completionHandler: @escaping (_ keyValid: Swift.Bool, _ keySunset: Swift.Bool, _ keyExpires: Swift.Int, _ keyLocator: Swift.String, _ error: Foundation.NSError?) -> Swift.Void)
  @objc dynamic public func sendGetLockerInfo(lockerId: Swift.Int, completionHandler: @escaping (_ lockerId: Swift.Int, _ lockerPhysicalId: Swift.Int, _ lockerTypeId: Swift.Int, _ lockerAvailable: Swift.Bool, _ lockerToken: Foundation.Data, _ lockerDisabled: Swift.Bool, _ keypadCode: Swift.String, _ keypadNextToken: Foundation.Data, _ keypadNextAvailable: Swift.Bool, _ keypadCodePersists: Swift.Bool, _ error: Foundation.NSError?) -> Swift.Void)
  @objc dynamic public func sendReadDeviceStatus(completionHandler: @escaping (_ temperature: Swift.Int, _ clockTime: Swift.Int, _ batteryCharge: Swift.Int, _ towerDisabled: Swift.Bool, _ towerReason: Swift.String, _ error: Foundation.NSError?) -> Swift.Void)
  @objc dynamic public func sendFireLock(lockerPhysicalId: Swift.Int, completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
  @objc dynamic public func sendControlLight(lockerPhysicalId: Swift.Int, lockerLightOn: Swift.Bool, completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
  @objc dynamic public func sendReadPortStatus(lockerPhysicalId: Swift.Int, completionHandler: @escaping (_ lockerLightOn: Swift.Bool, _ lockerLockFiring: Swift.Bool, _ lockerDoorOpen: Swift.Bool, _ error: Foundation.NSError?) -> Swift.Void)
  @objc dynamic public func sendSoundBuzzer(buzzerSound: Swift.Int, completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
  @objc dynamic public func sendSetClock(timestamp: Swift.Int, completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
  @objc dynamic public func sendSetSolenoidDelay(solenoidDelay: Swift.Int, completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
  @objc dynamic public func sendReadKeypad(completionHandler: @escaping (_ keysHeld: Swift.Int, _ keysPressed: Swift.Int, _ keysReleased: Swift.Int, _ error: Foundation.NSError?) -> Swift.Void)
  @objc dynamic public func sendSetLockerToken(lockerId: Swift.Int, lockerToken: Foundation.Data, completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
  @objc dynamic public func sendSetLockerAvailable(lockerId: Swift.Int, lockerAvailable: Swift.Bool, completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
  @objc dynamic public func sendSetLockerKeypad(lockerId: Swift.Int, keypadCode: Swift.String, keypadCodePersists: Swift.Bool, keypadNextToken: Foundation.Data, keypadNextAvailable: Swift.Bool, completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
  @objc dynamic public func sendSetLockerDisabled(lockerId: Swift.Int, lockerDisabled: Swift.Bool, completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
  @objc dynamic public func sendReadCounter(counterId: Swift.Int, completionHandler: @escaping (_ counterId: Swift.Int, _ counterValue: Swift.Int, _ counterLastReset: Swift.Int, _ error: Foundation.NSError?) -> Swift.Void)
  @objc dynamic public func sendResetCounter(counterId: Swift.Int, completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
  @objc dynamic public func sendSetTowerId(towerId: Foundation.Data, completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
  @objc dynamic public func sendSetTowerSerial(towerSerial: Swift.String, completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
  @objc dynamic public func sendSetTowerName(towerName: Swift.String, completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
  @objc dynamic public func sendSetTowerDisabled(towerDisabled: Swift.Bool, towerReason: Swift.String, completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
  @objc dynamic public func sendResetBatteryGauge(completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
  @objc dynamic public func sendConfigureLocker(lockerId: Swift.Int, lockerPhysicalId: Swift.Int, lockerTypeId: Swift.Int, completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
  @objc dynamic public func sendAdjustClock(adjustClock: Swift.Int, completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
  @objc dynamic public func sendRebootDevice(completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
  @objc dynamic public func sendBeginFirmwareUpdate(clearAllState: Swift.Bool, fileURL: Foundation.URL, completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
  @objc dynamic public func sendFactoryReset(completionHandler: HarborLockersSDK.CommandSentResponseHandler?)
}
extension HarborLockersSDK.HarborSDK {
  @objc dynamic public func dfuProgressDidChange(for part: Swift.Int, outOf totalParts: Swift.Int, to progress: Swift.Int, currentSpeedBytesPerSecond: Swift.Double, avgSpeedBytesPerSecond: Swift.Double)
  @objc dynamic public func dfuStateDidChange(to state: HarborLockersSDK.DFUState)
  @objc dynamic public func dfuError(_ error: HarborLockersSDK.DFUError, didOccurWithMessage message: Swift.String)
}
@objc public enum DFUError : Swift.Int {
  case remoteLegacyDFUSuccess = 1
  case remoteLegacyDFUInvalidState = 2
  case remoteLegacyDFUNotSupported = 3
  case remoteLegacyDFUDataExceedsLimit = 4
  case remoteLegacyDFUCrcError = 5
  case remoteLegacyDFUOperationFailed = 6
  case remoteSecureDFUSuccess = 11
  case remoteSecureDFUOpCodeNotSupported = 12
  case remoteSecureDFUInvalidParameter = 13
  case remoteSecureDFUInsufficientResources = 14
  case remoteSecureDFUInvalidObject = 15
  case remoteSecureDFUSignatureMismatch = 16
  case remoteSecureDFUUnsupportedType = 17
  case remoteSecureDFUOperationNotPermitted = 18
  case remoteSecureDFUOperationFailed = 20
  case remoteSecureDFUExtendedError = 21
  case remoteExtendedErrorWrongCommandFormat = 22
  case remoteExtendedErrorUnknownCommand = 23
  case remoteExtendedErrorInitCommandInvalid = 24
  case remoteExtendedErrorFwVersionFailure = 25
  case remoteExtendedErrorHwVersionFailure = 26
  case remoteExtendedErrorSdVersionFailure = 27
  case remoteExtendedErrorSignatureMissing = 28
  case remoteExtendedErrorWrongHashType = 29
  case remoteExtendedErrorHashFailed = 30
  case remoteExtendedErrorWrongSignatureType = 31
  case remoteExtendedErrorVerificationFailed = 32
  case remoteExtendedErrorInsufficientSpace = 33
  case remoteExperimentalButtonlessDFUSuccess = 9001
  case remoteExperimentalButtonlessDFUOpCodeNotSupported = 9002
  case remoteExperimentalButtonlessDFUOperationFailed = 9004
  case remoteButtonlessDFUSuccess = 91
  case remoteButtonlessDFUOpCodeNotSupported = 92
  case remoteButtonlessDFUOperationFailed = 94
  case remoteButtonlessDFUInvalidAdvertisementName = 95
  case remoteButtonlessDFUBusy = 96
  case remoteButtonlessDFUNotBonded = 97
  case fileNotSpecified = 101
  case fileInvalid = 102
  case extendedInitPacketRequired = 103
  case initPacketRequired = 104
  case failedToConnect = 201
  case deviceDisconnected = 202
  case bluetoothDisabled = 203
  case serviceDiscoveryFailed = 301
  case deviceNotSupported = 302
  case readingVersionFailed = 303
  case enablingControlPointFailed = 304
  case writingCharacteristicFailed = 305
  case receivingNotificationFailed = 306
  case unsupportedResponse = 307
  case bytesLost = 308
  case crcError = 309
  case invalidInternalState = 500
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum DFUState : Swift.Int {
  case connecting
  case starting
  case enablingDfuMode
  case uploading
  case validating
  case disconnecting
  case completed
  case aborted
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@frozen public struct AnyCodable : Swift.Codable {
  public let value: Any
  public init<T>(_ value: T?)
}
extension HarborLockersSDK.AnyCodable : HarborLockersSDK._AnyEncodable, HarborLockersSDK._AnyDecodable {
}
extension HarborLockersSDK.AnyCodable : Swift.Equatable {
  public static func == (lhs: HarborLockersSDK.AnyCodable, rhs: HarborLockersSDK.AnyCodable) -> Swift.Bool
}
extension HarborLockersSDK.AnyCodable : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension HarborLockersSDK.AnyCodable : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension HarborLockersSDK.AnyCodable : Swift.ExpressibleByNilLiteral {
}
extension HarborLockersSDK.AnyCodable : Swift.ExpressibleByBooleanLiteral {
  public typealias BooleanLiteralType = Swift.Bool
}
extension HarborLockersSDK.AnyCodable : Swift.ExpressibleByIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int
}
extension HarborLockersSDK.AnyCodable : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Double
}
extension HarborLockersSDK.AnyCodable : Swift.ExpressibleByStringLiteral {
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension HarborLockersSDK.AnyCodable : Swift.ExpressibleByArrayLiteral {
  public typealias ArrayLiteralElement = Any
}
extension HarborLockersSDK.AnyCodable : Swift.ExpressibleByDictionaryLiteral {
  public typealias Key = Swift.AnyHashable
  public typealias Value = Any
}
public typealias APIResponseWithStatusCode = (_ responseCode: Swift.Int, _ error: Foundation.NSError?) -> Swift.Void
public typealias RequestTowerSessionAPIResponse = (_ payload: Foundation.Data?, _ payloadAuth: Foundation.Data?, _ sessionSeed: Foundation.Data?, _ towerId: Foundation.Data?, _ error: Foundation.NSError?) -> Swift.Void
public typealias RequestTowerConfigurationAPIResponse = (_ towerId: Foundation.Data?, _ commands: [Foundation.Data]?, _ error: Foundation.NSError?) -> Swift.Void
@objc public enum Environment : Swift.Int {
  case Development = 0
  case Sandbox = 2
  case Production = 3
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public protocol HarborLoggerDelegate : AnyObject {
  func harborDidLog(message: Swift.String, logType: HarborLockersSDK.HarborLogLevel, context: [Swift.String : Any]?)
}
@_hasMissingDesignatedInitializers public class HarborLogger {
  @objc deinit
}
extension HarborLockersSDK.CBOR.Undefined : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension HarborLockersSDK.CBOR.NegativeUInt64 : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension HarborLockersSDK.CBOR.SimpleValue : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension HarborLockersSDK.CBOR.Bignum : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension HarborLockersSDK.CBOR.DecimalFraction : Swift.Encodable where I1 : Swift.Encodable, I2 : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension HarborLockersSDK.CBOR.DecimalFraction : Swift.Decodable where I1 : Swift.Decodable, I2 : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension HarborLockersSDK.CBOR.Bigfloat : Swift.Encodable where I1 : Swift.Encodable, I2 : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension HarborLockersSDK.CBOR.Bigfloat : Swift.Decodable where I1 : Swift.Decodable, I2 : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension HarborLockersSDK.CBOR.IndefiniteLengthArray : Swift.Encodable where Element : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension HarborLockersSDK.CBOR.IndefiniteLengthArray : Swift.Decodable where Element : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension HarborLockersSDK.CBOR.IndefiniteLengthMap : Swift.Encodable where Key : Swift.Encodable, Value : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension HarborLockersSDK.CBOR.IndefiniteLengthMap : Swift.Decodable where Key : Swift.Decodable, Value : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension HarborLockersSDK.CBOR.IndefiniteLengthData : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension HarborLockersSDK.CBOR.IndefiniteLengthString : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension HarborLockersSDK.CBOR.CBOREncoded : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
@frozen public struct AnyEncodable : Swift.Encodable {
  public let value: Any
  public init<T>(_ value: T?)
}
@usableFromInline
internal protocol _AnyEncodable {
  var value: Any { get }
  init<T>(_ value: T?)
}
extension HarborLockersSDK.AnyEncodable : HarborLockersSDK._AnyEncodable {
}
extension HarborLockersSDK._AnyEncodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension HarborLockersSDK.AnyEncodable : Swift.Equatable {
  public static func == (lhs: HarborLockersSDK.AnyEncodable, rhs: HarborLockersSDK.AnyEncodable) -> Swift.Bool
}
extension HarborLockersSDK.AnyEncodable : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension HarborLockersSDK.AnyEncodable : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension HarborLockersSDK.AnyEncodable : Swift.ExpressibleByNilLiteral {
}
extension HarborLockersSDK.AnyEncodable : Swift.ExpressibleByBooleanLiteral {
  public typealias BooleanLiteralType = Swift.Bool
}
extension HarborLockersSDK.AnyEncodable : Swift.ExpressibleByIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int
}
extension HarborLockersSDK.AnyEncodable : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Double
}
extension HarborLockersSDK.AnyEncodable : Swift.ExpressibleByStringLiteral {
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension HarborLockersSDK.AnyEncodable : Swift.ExpressibleByStringInterpolation {
  public typealias StringInterpolation = Swift.DefaultStringInterpolation
}
extension HarborLockersSDK.AnyEncodable : Swift.ExpressibleByArrayLiteral {
  public typealias ArrayLiteralElement = Any
}
extension HarborLockersSDK.AnyEncodable : Swift.ExpressibleByDictionaryLiteral {
  public typealias Key = Swift.AnyHashable
  public typealias Value = Any
}
extension HarborLockersSDK._AnyEncodable {
  public init(nilLiteral _: ())
  public init(booleanLiteral value: Swift.Bool)
  public init(integerLiteral value: Swift.Int)
  public init(floatLiteral value: Swift.Double)
  public init(extendedGraphemeClusterLiteral value: Swift.String)
  public init(stringLiteral value: Swift.String)
  public init(arrayLiteral elements: Any...)
  public init(dictionaryLiteral elements: (Swift.AnyHashable, Any)...)
}
extension HarborLockersSDK.Half : Swift.Codable {
  @_transparent public init(from decoder: Swift.Decoder) throws {
        let container = try decoder.singleValueContainer()
        let float = try container.decode(Float.self)

        guard float.isInfinite || float.isNaN || abs(float) <= Float(Half.greatestFiniteMagnitude) else {
            throw DecodingError.dataCorrupted(DecodingError.Context(codingPath: container.codingPath, debugDescription: "Parsed number \(float) does not fit in \(type(of: self))."))
        }

        self.init(float)
    }
  @_transparent public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(Float(self))
    }
}
extension HarborLockersSDK.HarborLogLevel : Swift.Equatable {}
extension HarborLockersSDK.HarborLogLevel : Swift.Hashable {}
extension HarborLockersSDK.HarborLogLevel : Swift.RawRepresentable {}
extension HarborLockersSDK.SessionPermission : Swift.Equatable {}
extension HarborLockersSDK.SessionPermission : Swift.Hashable {}
extension HarborLockersSDK.SessionPermission : Swift.RawRepresentable {}
extension HarborLockersSDK.Half : Swift.Sendable {}
extension HarborLockersSDK.CBOREncoder.DateEncodingStrategy : Swift.Equatable {}
extension HarborLockersSDK.CBOREncoder.DateEncodingStrategy : Swift.Hashable {}
extension HarborLockersSDK.DFUError : Swift.Equatable {}
extension HarborLockersSDK.DFUError : Swift.Hashable {}
extension HarborLockersSDK.DFUError : Swift.RawRepresentable {}
extension HarborLockersSDK.DFUState : Swift.Equatable {}
extension HarborLockersSDK.DFUState : Swift.Hashable {}
extension HarborLockersSDK.DFUState : Swift.RawRepresentable {}
extension HarborLockersSDK.Environment : Swift.Equatable {}
extension HarborLockersSDK.Environment : Swift.Hashable {}
extension HarborLockersSDK.Environment : Swift.RawRepresentable {}
