#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.6.1 (swiftlang-5.6.0.323.66 clang-1316.0.20.12)
#ifndef HARBORLOCKERSSDK_SWIFT_H
#define HARBORLOCKERSSDK_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="HarborLockersSDK",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif



typedef SWIFT_ENUM(NSInteger, DFUError, open) {
  DFUErrorRemoteLegacyDFUSuccess = 1,
  DFUErrorRemoteLegacyDFUInvalidState = 2,
  DFUErrorRemoteLegacyDFUNotSupported = 3,
  DFUErrorRemoteLegacyDFUDataExceedsLimit = 4,
  DFUErrorRemoteLegacyDFUCrcError = 5,
  DFUErrorRemoteLegacyDFUOperationFailed = 6,
  DFUErrorRemoteSecureDFUSuccess = 11,
  DFUErrorRemoteSecureDFUOpCodeNotSupported = 12,
  DFUErrorRemoteSecureDFUInvalidParameter = 13,
  DFUErrorRemoteSecureDFUInsufficientResources = 14,
  DFUErrorRemoteSecureDFUInvalidObject = 15,
  DFUErrorRemoteSecureDFUSignatureMismatch = 16,
  DFUErrorRemoteSecureDFUUnsupportedType = 17,
  DFUErrorRemoteSecureDFUOperationNotPermitted = 18,
  DFUErrorRemoteSecureDFUOperationFailed = 20,
  DFUErrorRemoteSecureDFUExtendedError = 21,
  DFUErrorRemoteExtendedErrorWrongCommandFormat = 22,
  DFUErrorRemoteExtendedErrorUnknownCommand = 23,
  DFUErrorRemoteExtendedErrorInitCommandInvalid = 24,
  DFUErrorRemoteExtendedErrorFwVersionFailure = 25,
  DFUErrorRemoteExtendedErrorHwVersionFailure = 26,
  DFUErrorRemoteExtendedErrorSdVersionFailure = 27,
  DFUErrorRemoteExtendedErrorSignatureMissing = 28,
  DFUErrorRemoteExtendedErrorWrongHashType = 29,
  DFUErrorRemoteExtendedErrorHashFailed = 30,
  DFUErrorRemoteExtendedErrorWrongSignatureType = 31,
  DFUErrorRemoteExtendedErrorVerificationFailed = 32,
  DFUErrorRemoteExtendedErrorInsufficientSpace = 33,
  DFUErrorRemoteExperimentalButtonlessDFUSuccess = 9001,
  DFUErrorRemoteExperimentalButtonlessDFUOpCodeNotSupported = 9002,
  DFUErrorRemoteExperimentalButtonlessDFUOperationFailed = 9004,
  DFUErrorRemoteButtonlessDFUSuccess = 91,
  DFUErrorRemoteButtonlessDFUOpCodeNotSupported = 92,
  DFUErrorRemoteButtonlessDFUOperationFailed = 94,
  DFUErrorRemoteButtonlessDFUInvalidAdvertisementName = 95,
  DFUErrorRemoteButtonlessDFUBusy = 96,
  DFUErrorRemoteButtonlessDFUNotBonded = 97,
/// Providing the DFUFirmware is required.
  DFUErrorFileNotSpecified = 101,
/// Given firmware file is not supported.
  DFUErrorFileInvalid = 102,
/// Since SDK 7.0.0 the DFU Bootloader requires the extended Init Packet.
/// For more details, see:
/// http://infocenter.nordicsemi.com/topic/com.nordic.infocenter.sdk5.v11.0.0/bledfu_example_init.html?cp=4_0_0_4_2_1_1_3
  DFUErrorExtendedInitPacketRequired = 103,
/// Before SDK 7.0.0 the init packet could have contained only 2-byte CRC
/// value, and was optional. Providing an extended one instead would cause
/// CRC error during validation (the bootloader assumes that the 2 first
/// bytes of the init packet are the firmware CRC).
  DFUErrorInitPacketRequired = 104,
  DFUErrorFailedToConnect = 201,
  DFUErrorDeviceDisconnected = 202,
  DFUErrorBluetoothDisabled = 203,
  DFUErrorServiceDiscoveryFailed = 301,
  DFUErrorDeviceNotSupported = 302,
  DFUErrorReadingVersionFailed = 303,
  DFUErrorEnablingControlPointFailed = 304,
  DFUErrorWritingCharacteristicFailed = 305,
  DFUErrorReceivingNotificationFailed = 306,
  DFUErrorUnsupportedResponse = 307,
/// Error raised during upload when the number of bytes sent is not equal to
/// number of bytes confirmed in Packet Receipt Notification.
  DFUErrorBytesLost = 308,
/// Error raised when the CRC reported by the remote device does not match.
/// Service has done 3 attempts to send the data.
  DFUErrorCrcError = 309,
/// The service went into an invalid state. The service will try to close
/// without crashing. Recovery to a know state is not possible.
  DFUErrorInvalidInternalState = 500,
};

/// The state of the DFU Service.
/// <ul>
///   <li>
///     connecting:      Service is connecting to the DFU target.
///   </li>
///   <li>
///     starting:        DFU Service is initializing DFU operation.
///   </li>
///   <li>
///     enablingDfuMode: Service is switching the device to DFU mode.
///   </li>
///   <li>
///     uploading:       Service is uploading the firmware.
///   </li>
///   <li>
///     validating:      The DFU target is validating the firmware.
///   </li>
///   <li>
///     disconnecting:   The iDevice is disconnecting or waiting for disconnection.
///   </li>
///   <li>
///     completed:       DFU operation is completed and successful.
///   </li>
///   <li>
///     aborted:         DFU Operation was aborted.
///   </li>
/// </ul>
typedef SWIFT_ENUM(NSInteger, DFUState, open) {
  DFUStateConnecting = 0,
  DFUStateStarting = 1,
  DFUStateEnablingDfuMode = 2,
  DFUStateUploading = 3,
  DFUStateValidating = 4,
  DFUStateDisconnecting = 5,
  DFUStateCompleted = 6,
  DFUStateAborted = 7,
};

typedef SWIFT_ENUM(NSInteger, Environment, open) {
  EnvironmentDevelopment = 0,
  EnvironmentSandbox = 2,
  EnvironmentProduction = 3,
};


@protocol HarborSDKDelegate;
@class NSString;
@class NSError;
@class Tower;

SWIFT_CLASS("_TtC16HarborLockersSDK9HarborSDK")
@interface HarborSDK : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) HarborSDK * _Nonnull shared;)
+ (HarborSDK * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, strong) id <HarborSDKDelegate> _Null_unspecified delegate;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
- (BOOL)isSyncing SWIFT_WARN_UNUSED_RESULT;
- (void)setBaseURL:(NSString * _Nonnull)baseURL;
- (void)loginWithEmail:(NSString * _Nonnull)email password:(NSString * _Nonnull)password completion:(void (^ _Nonnull)(NSInteger, NSError * _Nullable))completion;
- (void)setAccessToken:(NSString * _Nonnull)token;
- (void)setEnvironment:(enum Environment)environment;
- (void)downloadTowerConfigurationWithCompletion:(void (^ _Nonnull)(BOOL))completion;
- (void)startTowerDiscovery;
- (void)connectToTower:(Tower * _Nonnull)tower completion:(void (^ _Nonnull)(NSString * _Nullable, NSError * _Nullable))completion;
@end



@interface HarborSDK (SWIFT_EXTENSION(HarborLockersSDK))
- (void)dfuProgressDidChangeFor:(NSInteger)part outOf:(NSInteger)totalParts to:(NSInteger)progress currentSpeedBytesPerSecond:(double)currentSpeedBytesPerSecond avgSpeedBytesPerSecond:(double)avgSpeedBytesPerSecond;
- (void)dfuStateDidChangeTo:(enum DFUState)state;
- (void)dfuError:(enum DFUError)error didOccurWithMessage:(NSString * _Nonnull)message;
@end

@class NSData;
enum SessionPermission : NSInteger;
@class NSDate;
@class NSURL;

@interface HarborSDK (SWIFT_EXTENSION(HarborLockersSDK))
- (void)syncWithCompletionHandler:(void (^ _Nonnull)(BOOL, NSError * _Nullable))completionHandler;
/// Establishes a session with a tower. This is a convenience method that can be used if you don’t want to store the Request session payload, payload auth and session seed to send it later. The SDK must be initialized with the provider credentials as the Harbor API will verify it can provide a session with the requested permissions.
/// \param towerId The ID of the tower you want to connect to. If none is provided, it’ll request a session to the connected tower.
///
/// \param duration The duration while the requested session packet will be valid to establish a session.
///
/// \param sessionPermissions Session permissions to request for.
///
/// \param completionHandler Success if the session was granted successfully.
///
- (void)establishSessionWithTowerId:(NSData * _Nullable)towerId duration:(NSInteger)duration sessionPermissions:(enum SessionPermission)sessionPermissions completionHandler:(void (^ _Nonnull)(BOOL, NSError * _Nullable))completionHandler;
/// Requests a session token to connect to a specified tower. The SDK must be initialized with the provider credentials as the Harbor API will verify it can provide a session with the requested permissions. The returned payload, payloadAuth and sessionSeed must be passed to the <code>sendRequestSession</code> method. These values can be stored to connect to the tower while being offline.
/// \param towerId The ID of the tower you want to connect to. If none is provided, it’ll request a session to the connected tower.
///
/// \param duration The duration while the requested session packet will be valid to establish a session.
///
/// \param sessionPermissions Session permissions to request for.
///
/// \param completionHandler A completion handler containing the payload, payloadAuth and sessionSeed that must be provided to the <code>sendRequestSession</code> method to establish the session with the tower.
///
- (void)getSessionRequestWithTowerId:(NSData * _Nullable)towerId duration:(NSInteger)duration sessionPermissions:(enum SessionPermission)sessionPermissions completionHandler:(void (^ _Nonnull)(NSData * _Nullable, NSData * _Nullable, NSData * _Nullable, NSData * _Nullable, NSError * _Nullable))completionHandler;
/// Creates a Request Session packet and send it to the connected device to establish a session. A Grant Session response is automatically processed by this function to execute the completion handler
/// \param payloadAuth Payload auth provided by the server. Contains the signature of the encrypted payload.
///
/// \param payload Encrypted payload provided by the server.
///
/// \param sessionSeed A seed provided by the server to validate a session once it’s established.
///
/// \param completionHandler Success if the session was granted successfully.
///
- (void)sendRequestSessionWithPayloadAuth:(NSData * _Nonnull)payloadAuth payload:(NSData * _Nonnull)payload sessionSeed:(NSData * _Nonnull)sessionSeed completionHandler:(void (^ _Nonnull)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Terminate Session packet and send it to the connected device to terminate a session. If the provided error code is > 0, an <code>errorMessage</code> must be provided and the device will log an Error Event with the provided error code and error message.
/// \param errorCode A code to log in the terminate session event on the device side. May be 0 if no error occurred.
///
/// \param errorMessage The message to store in the error event log.
///
/// \param completionHandler Success if the session was terminated successfully.
///
- (void)sendTerminateSessionWithErrorCode:(NSInteger)errorCode errorMessage:(NSString * _Nullable)errorMessage disconnectAfterSessionTerminated:(BOOL)disconnectAfterSessionTerminated completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Technician/System command. Creates an Install Key packet and send it to the connected device.
/// \param keyId The key slot to replace in the device. Must be a number between 1 and 4.
///
/// \param keyRotation 0 = green, 1 = blue, 2 = fallback
///
/// \param keyExpires The expiration date of the key being installed.
///
/// \param keyData 32 or 64 bytes with the bytes of the key to be installed.
///
/// \param keyLocator A user friendly identifier for the key. This will be returned when requesting the key info.
///
/// \param completionHandler Success if the key was installed.
///
- (void)sendInstallKeyWithKeyId:(NSInteger)keyId keyRotation:(NSInteger)keyRotation keyExpires:(NSDate * _Nonnull)keyExpires keyData:(NSData * _Nonnull)keyData keyLocator:(NSString * _Nonnull)keyLocator completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Technician/System command. Creates a Sunset Key packet and send it to the connected device.
/// \param keyId The key slot to sunset in the device. Must be a number between 1 and 4.
///
/// \param keyRotation 0 = green, 1 = blue, 2 = fallback
///
/// \param completionHandler Success if the key was sunsetted.
///
- (void)sendSunsetKeyWithKeyId:(NSInteger)keyId keyRotation:(NSInteger)keyRotation completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Technician/System command. Creates an Revoke Key packet and send it to the connected device.
/// \param keyId The key slot to revoke in the device. Must be a number between 1 and 4.
///
/// \param keyRotation 0 = green, 1 = blue, 2 = fallback
///
/// \param completionHandler Success if the key was revoked.
///
- (void)sendRevokeKeyWithKeyId:(NSInteger)keyId keyRotation:(NSInteger)keyRotation completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates an Request Sync Status packet and send it to the connected device. In order to validate the response data, you need to check for the error object in the completion handler. If a valid Request Sync Status message is sent, the completion handler will have the Sync Status information.
/// \param completionHandler A completion handler block
///
/// \param syncEventStart The first Event ID available to be read
///
/// \param syncEventCount The amount of available events to read
///
/// \param syncCommandStart The last server command that the device executed.
///
/// \param error An error returned by the device.
///
- (void)sendRequestSyncStatusWithCompletionHandler:(void (^ _Nonnull)(NSInteger, NSInteger, NSInteger, NSError * _Nullable))completionHandler;
/// Creates an Sync Pull packet and send it to the connected device. The device will respond with the events available. In order to validate the response data, you need to check for the error object in the completion handler. If a valid Sync Pull command is sent, the completion handler will have the events information.
/// \param syncEventStart The first Event ID you want to read from the device.
///
/// \param completionHandler A completion handler block
///
/// \param firstEventId The first Event ID returned by the device
///
/// \param syncEventCount The amount of events returned by the device in the payload.
///
/// \param payload Encrypted payload with all the events data. This needs to be sent to the server.
///
/// \param payloadAuth Signature of the payload. This needs to be sent to the server.
///
/// \param error An error returned by the device.
///
- (void)sendSyncPullWithSyncEventStart:(uint32_t)syncEventStart completionHandler:(void (^ _Nonnull)(NSInteger, NSInteger, NSData * _Nonnull, NSData * _Nonnull, NSError * _Nullable))completionHandler;
/// Creates an Sync Push packet and send it to the connected device.
/// \param payload Encrypted payload with all the commands data. This needs to be provided by the server.
///
/// \param payloadAuth Signature of the payload. This needs to be provided by the server.
///
/// \param completionHandler Success if the commands were sent.
///
- (void)sendSyncPushWithPayload:(NSData * _Nonnull)payload payloadAuth:(NSData * _Nonnull)payloadAuth completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Mark Seen Events packet and send it to the connected device.
/// \param syncEventStart Next expected Event ID from the device
///
/// \param completionHandler Success if the seen event was marked.
///
- (void)sendMarkSeenEventsWithSyncEventStart:(uint32_t)syncEventStart completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Reset Event Counter packet and send it to the connected device.
/// \param syncEventStart ID to assign to the device’s log ID counter.
///
/// \param completionHandler Success if the event counter was reset.
///
- (void)sendResetEventCounterWithSyncEventStart:(uint32_t)syncEventStart completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Reset Command Counter packet and send it to the connected device.
/// \param syncCommandStart Next expected command sync ID from the server
///
/// \param completionHandler Success if the command counter was reset.
///
- (void)sendResetCommandCounterWithSyncCommandStart:(uint32_t)syncCommandStart completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates an Add Client Event packet and send it to the connected device.
/// \param clientInfo Data to log in the event (max 500 bytes)
///
/// \param completionHandler Success if the event was logged.
///
- (void)sendAddClientEventWithClientInfo:(NSData * _Nonnull)clientInfo completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Find Available Lockers packet and send it to the connected device. The device will respond with the available lockers info. In order to validate the response data, you need to check for the error object in the completion handler. If a valid Find Available Locker command is sent, the completion handler will have the lockers information.
/// \param completionHandler A completion handler block
///
/// \param availableLockers A map containing locker types as keys, and the amount of available lockers for each type as values. If the device returns an error, this value will be nil.
///
/// \param error An error returned by the device.
///
- (void)sendFindAvailableLockersWithCompletionHandler:(void (^ _Nonnull)(NSDictionary<NSNumber *, NSNumber *> * _Nullable, NSError * _Nullable))completionHandler;
/// Creates a Find Lockers with Token packet and send it to the connected device. The device will respond with the available lockers info that matches the provided details. In order to validate the response data, you need to check for the error object in the completion handler. If a valid Find Available Locker command is sent, the completion handler will have the lockers information.
/// \param matchAvailable Specifies if the device should find an available locker or not.
///
/// \param matchToken Specifies the token the locker should have in order to be considered a match by the device.
///
/// \param completionHandler A completion handler block
///
/// \param availableLockers A map containing locker types as keys, and the amount of available lockers for each type as values. If the device returns an error, this value will be nil.
///
/// \param error An error returned by the device.
///
- (void)sendFindLockersWithTokenWithMatchAvailable:(BOOL)matchAvailable matchToken:(NSData * _Nonnull)matchToken completionHandler:(void (^ _Nonnull)(NSDictionary<NSNumber *, NSNumber *> * _Nullable, NSError * _Nullable))completionHandler;
/// Creates an Open Locker With Token packet and send it to the connected device. The device will respond with the opened locker ID. In order to validate the response data, you need to check for the error object in the completion handler. If a valid Open Locker With Token command is sent, the completion handler will have the opened locker ID.
/// \param payload Encrypted payload provided by the server to open the locker.
///
/// \param payloadAuth Signature of the payload. This needs to be provided by the server.
///
/// \param completionHandler A completion handler block
///
/// \param lockerId The locker ID of the opened locker. Will be -1 if no locker was opened.
///
/// \param error An error returned by the device.
///
- (void)sendOpenLockerWithTokenWithPayload:(NSData * _Nonnull)payload payloadAuth:(NSData * _Nonnull)payloadAuth completionHandler:(void (^ _Nonnull)(NSInteger, NSError * _Nullable))completionHandler;
/// Creates an Open Available Locker packet and send it to the connected device. The device will respond with the opened locker ID. In order to validate the response data, you need to check for the error object in the completion handler. If a valid Open Available Locker command is sent, the completion handler will have the opened locker ID.
/// \param matchLockerType The locker type to be considered by the device. This is a required field to ensure ObjC compatibility. If a negative number is passed, this field will not be sent to the device and any locker in the tower will be considered.
///
/// \param matchAvailable Specifies the required value for the ‘available’ state of lockers to consider.
///
/// \param matchToken If present, locker to be considered must contain this token. By default, no specific token value is required.
///
/// \param lockerToken The new token value to assign to this locker. Leave empty data for auto-assignment.
///
/// \param lockerAvailable The new ‘available’ flag for this locker
///
/// \param clientInfo Opaque data from the client to associate with this delivery.
///
/// \param completionHandler A completion handler block
///
/// \param lockerId The locker ID of the opened locker. Will be -1 if no locker was opened.
///
/// \param error An error returned by the device.
///
- (void)sendOpenAvailableLockerWithMatchLockerType:(NSInteger)matchLockerType matchAvailable:(BOOL)matchAvailable matchToken:(NSData * _Nullable)matchToken lockerToken:(NSData * _Nonnull)lockerToken lockerAvailable:(BOOL)lockerAvailable clientInfo:(NSData * _Nonnull)clientInfo completionHandler:(void (^ _Nonnull)(NSInteger, NSError * _Nullable))completionHandler;
/// Creates a Reopen Locker packet and send it to the connected device. The device will respond with the opened locker ID. In order to validate the response data, you need to check for the error object in the completion handler. If a valid Reopen Locker command is sent, the completion handler will have the opened locker ID.
/// \param completionHandler A completion handler block
///
/// \param lockerId The locker ID of the opened locker. Will be -1 if no locker was opened.
///
/// \param error An error returned by the device.
///
- (void)sendReopenLockerWithCompletionHandler:(void (^ _Nonnull)(NSInteger, NSError * _Nullable))completionHandler;
/// Creates a Check Locker Door packet and send it to the connected device. The device will respond with a bool value indicating if the door is open. If an error occurs, the bool value will be false and the error object will be present.
/// \param completionHandler A completion handler block
///
/// \param doorOpen A flag indicating if the door is open or not. If an error is present, this value can be ignored.
///
/// \param error An error returned by the device.
///
- (void)sendCheckLockerDoorWithCompletionHandler:(void (^ _Nonnull)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Revert Locker State packet and send it to the connected device.
/// \param clientInfo Client information to be logged in an event in case it’s needed.
///
/// \param completionHandler Success if the locker state was reverted.
///
- (void)sendRevertLockerStateWithClientInfo:(NSData * _Nonnull)clientInfo completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Set Keypad Code packet and send it to the connected device.
/// \param keypadCode Code to access the locker, as a string of ASCII digits or the word “auto”. Disables keypad access if empty. Must be between 4 and 10 digits (inclusive).
///
/// \param keypadCodePersists If true, does not erase the keypad access code after a single use.
///
/// \param keypadNextToken Specifies a new active token value to assign if the keypad access code is used.
///
/// \param keypadNextAvailable Specifies a new locker available flag to assign if the keypad access code is used
///
/// \param completionHandler Success if the keypad code was set successfully.
///
- (void)sendSetKeypadCodeWithKeypadCode:(NSString * _Nonnull)keypadCode keypadCodePersists:(BOOL)keypadCodePersists keypadNextToken:(NSData * _Nonnull)keypadNextToken keypadNextAvailable:(BOOL)keypadNextAvailable completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Tap Locker packet and send it to the connected device.
/// \param lockerTapIntervalMS Set the interval between locker “taps” (extra firing of the solenoid to make a tapping sound).
///
/// \param lockerTapCount How many extra times to “tap” the locker (0 for tapping the locker just once).
///
/// \param completionHandler Success if the command was received successfully by the device.
///
- (void)sendTapLockerWithLockerTapIntervalMS:(NSInteger)lockerTapIntervalMS lockerTapCount:(NSInteger)lockerTapCount completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Check All Locker Doors packet and send it to the connected device. In order to validate the response data, you need to check for the error object in the completion handler. If a valid Check All Locker Doors command is sent, the completion handler will have the the locker doors states.
/// \param completionHandler A completion handler block
///
/// \param lockerDoorsOpen Binary string with bitfields indexed by logical locker ID. Each bit index represent a door closed (0) or open (1).
///
/// \param error An error returned by the device.
///
- (void)sendCheckAllLockerDoorsWithCompletionHandler:(void (^ _Nonnull)(NSData * _Nullable, NSError * _Nullable))completionHandler;
/// Creates a Get Device Info packet and send it to the connected device. In order to validate the response data, you need to check for the error object in the completion handler. If a valid Get Device Info command is sent, the completion handler will have the the device info values.
/// \param completionHandler A completion handler block
///
/// \param towerId The tower ID configured in the device
///
/// \param towerName The tower name configured in the device
///
/// \param deviceModel The device model of the device.
///
/// \param deviceSerial The device serial of the device.
///
/// \param towerSerial The tower serial of the device.
///
/// \param firmwareVersion The firmware version running on the device.
///
/// \param mainboardId The ID of the mainboard
///
/// \param shield1Id The ID of the first detected shield.
///
/// \param shield2Id The ID of the second detected shield
///
/// \param solenoidDelay The delay set for the solenoids in the device.
///
/// \param error An error returned by the device.
///
- (void)sendGetDeviceInfoWithCompletionHandler:(void (^ _Nonnull)(NSData * _Nonnull, NSString * _Nonnull, NSString * _Nonnull, NSString * _Nonnull, NSString * _Nonnull, NSString * _Nonnull, NSInteger, NSInteger, NSInteger, NSInteger, NSError * _Nullable))completionHandler;
/// Creates a Get Key Info packet and send it to the connected device. In order to validate the response data, you need to check for the error object in the completion handler. If a valid Get Key Info command is sent, the completion handler will have the the key info values.
/// \param keyId The ID of the Key you want to request the info from.
///
/// \param keyRotation The key rotation you want to request the info from.
///
/// \param completionHandler A completion handler block
///
/// \param keyValid Whether the key is valid now
///
/// \param keySunset Sunset flag indicating if the key is marked as sunsetted or not.
///
/// \param keyExpires An int representing the timestamp when a key will become invalid.
///
/// \param keyLocator Locator data for this key. This is a string associated to the key when it was installed.
///
/// \param error An error returned by the device.
///
- (void)sendGetKeyInfoWithKeyId:(NSInteger)keyId keyRotation:(NSInteger)keyRotation completionHandler:(void (^ _Nonnull)(BOOL, BOOL, NSInteger, NSString * _Nonnull, NSError * _Nullable))completionHandler;
/// Creates a Get Locker Info packet and send it to the connected device. In order to validate the response data, you need to check for the error object in the completion handler. If a valid Get Locker Info command is sent, the completion handler will have the the locker info values.
/// \param lockerId The ID of the locker requesting the info for.
///
/// \param completionHandler A completion handler block
///
/// \param lockerPhysicalId Which port the locker is associated with.
///
/// \param lockerTypeId Configured locker type.
///
/// \param lockerAvailable Whether the locker is available or not.
///
/// \param lockerToken Current locker token, if any is associated.
///
/// \param lockerDisabled Whether the locker is disabled or not.
///
/// \param keypadCode Current keypad code for pickup
///
/// \param keypadNextToken Token to be set after the keypad code is used.
///
/// \param keypadNextAvailable Available flag value to be set after the keypad code is used.
///
/// \param keypadCodePersists A flag indicating if the keypad code persists after it’s used.
///
/// \param error An error returned by the device.
///
- (void)sendGetLockerInfoWithLockerId:(NSInteger)lockerId completionHandler:(void (^ _Nonnull)(NSInteger, NSInteger, NSInteger, BOOL, NSData * _Nonnull, BOOL, NSString * _Nonnull, NSData * _Nonnull, BOOL, BOOL, NSError * _Nullable))completionHandler;
/// Creates a Read Device Status packet and send it to the connected device. In order to validate the response data, you need to check for the error object in the completion handler. If a valid Read Device Status command is sent, the completion handler will have the the device status values.
/// \param completionHandler A completion handler block
///
/// \param temperature Current temperature in Celsius degrees, as a fixed-point integer with 4 bits of fraction.
///
/// \param clockTime Current date and time, according to the RTC
///
/// \param batteryCharge How much charge is remaining in the battery (estimated)
///
/// \param towerDisabled A flag indicating whether the tower is disabled or not.
///
/// \param towerReason The reason given for the tower being disabled.
///
/// \param error An error returned by the device.
///
- (void)sendReadDeviceStatusWithCompletionHandler:(void (^ _Nonnull)(NSInteger, NSInteger, NSInteger, BOOL, NSString * _Nonnull, NSError * _Nullable))completionHandler;
/// Creates a Fire Lock packet and send it to the connected device.
/// \param lockerPhysicalId The port of the lock to fire.
///
/// \param completionHandler Success if the lock was fired.
///
- (void)sendFireLockWithLockerPhysicalId:(NSInteger)lockerPhysicalId completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Control Light packet and send it to the connected device.
/// \param lockerPhysicalId The port of the lock to control the light of.
///
/// \param lockerLightOn Whether to turn on or off the light on the lock.
///
/// \param completionHandler Success if the command was sent successfully.
///
- (void)sendControlLightWithLockerPhysicalId:(NSInteger)lockerPhysicalId lockerLightOn:(BOOL)lockerLightOn completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Read Port Status packet and send it to the connected device. In order to validate the response data, you need to check for the error object in the completion handler. If a valid Read Port Status command is sent, the completion handler will have the the device status values.
/// \param lockerPhysicalId The port to request the status from.
///
/// \param completionHandler A completion handler block
///
/// \param lockerLightOn Whether the light is on or not.
///
/// \param lockerLockFiring Whether the lock is currently firing or not.
///
/// \param lockerDoorOpen Whether the door sensor reports the door being open.
///
/// \param error An error returned by the device.
///
- (void)sendReadPortStatusWithLockerPhysicalId:(NSInteger)lockerPhysicalId completionHandler:(void (^ _Nonnull)(BOOL, BOOL, BOOL, NSError * _Nullable))completionHandler;
/// Creates a Sound Buzzer packet and send it to the connected device.
/// \param buzzerSound An integer interpreted as a pattern of bits. These are to be arranged from least significant to most significant, with each bit representing a 100ms interval. If a bit is set, the buzzer is expected to be on for the interval, otherwise it should be silent for the interval.
///
/// \param completionHandler Success if the command was sent successfully.
///
- (void)sendSoundBuzzerWithBuzzerSound:(NSInteger)buzzerSound completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Set Clock packet and send it to the connected device.
/// \param timestamp A POSIX timestamp to set in the RTC. This time should come from the current device’s time, assuming the device is synced with a time server.
///
/// \param completionHandler Success if the clock was set correctly.
///
- (void)sendSetClockWithTimestamp:(NSInteger)timestamp completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Set Solenoid Delay packet and send it to the connected device.
/// \param solenoidDelay How long to hold the solenoid lock open, in milliseconds.
///
/// \param completionHandler Success if the solenoid delay was set correctly.
///
- (void)sendSetSolenoidDelayWithSolenoidDelay:(NSInteger)solenoidDelay completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Read Keypad packet and send it to the connected device. In order to validate the response data, you need to check for the error object in the completion handler. If a valid Read Keypad command is sent, the completion handler will have the the keypad info.
/// The bit assignments for the keys are as follows:
/// <ul>
///   <li>
///     Bit 0 - key ‘0’
///   </li>
///   <li>
///     Bit 1 - key ‘1’
///   </li>
///   <li>
///     …
///   </li>
///   <li>
///     Bit 9 - key ‘9’
///   </li>
///   <li>
///     Bit 10 - key ‘*’ (if present)
///   </li>
///   <li>
///     Bit 11 - key ‘#’ (if present)
///   </li>
///   <li>
///     Bit 12 - key ‘Enter’ (if present)
///   </li>
/// </ul>
/// \param completionHandler A completion handler block
///
/// \param keysHeld A bitmap of keys currently held down.
///
/// \param keysPressed A bitmap of keys newly pressed.
///
/// \param keysReleased A bitmap of keys newly released.
///
/// \param error An error returned by the device.
///
- (void)sendReadKeypadWithCompletionHandler:(void (^ _Nonnull)(NSInteger, NSInteger, NSInteger, NSError * _Nullable))completionHandler;
/// Creates a Set Locker Token packet and send it to the connected device.
/// \param lockerId The ID of the locker to set the token for.
///
/// \param lockerToken The token to set to the locker.
///
/// \param completionHandler Success if the token was set correctly.
///
- (void)sendSetLockerTokenWithLockerId:(NSInteger)lockerId lockerToken:(NSData * _Nonnull)lockerToken completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Set Locker Available packet and send it to the connected device.
/// \param lockerId The ID of the locker to set as available.
///
/// \param lockerAvailable Whether to set the locker as available or not.
///
/// \param completionHandler Success if the token was set correctly.
///
- (void)sendSetLockerAvailableWithLockerId:(NSInteger)lockerId lockerAvailable:(BOOL)lockerAvailable completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Set Locker Keypad packet and send it to the connected device.
/// \param lockerId The ID of the locker to set the keypad code for.
///
/// \param keypadCode The keypad code to set to the locker.
///
/// \param keypadCodePersists Whether the keypad code will persist after it’s used to open the locker.
///
/// \param keypadNextToken The token to assign to the locker if it’s open with the Keypad code.
///
/// \param keypadNextAvailable The availability flag to assign to the locker once it’s opened with the Keypad.
///
/// \param completionHandler Success if the token was set correctly.
///
- (void)sendSetLockerKeypadWithLockerId:(NSInteger)lockerId keypadCode:(NSString * _Nonnull)keypadCode keypadCodePersists:(BOOL)keypadCodePersists keypadNextToken:(NSData * _Nonnull)keypadNextToken keypadNextAvailable:(BOOL)keypadNextAvailable completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Set Locker Disabled packet and send it to the connected device.
/// \param lockerId The ID of the locker to set the disabled flag.
///
/// \param lockerDisabled Whether to disable the locker or not.
///
/// \param completionHandler Success if the token was set correctly.
///
- (void)sendSetLockerDisabledWithLockerId:(NSInteger)lockerId lockerDisabled:(BOOL)lockerDisabled completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Read Counter packet and send it to the connected device. In order to validate the response data, you need to check for the error object in the completion handler. If a valid Read Counter command is sent, the completion handler will have the the counter value.
/// \param counterId The ID of the counter to read the value from.
///
/// \param completionHandler A completion handler block
///
/// \param counterValue The value of the counter
///
/// \param counterLastReset A POSIX timestamp when the counter was last reset.
///
/// \param error An error returned by the device.
///
- (void)sendReadCounterWithCounterId:(NSInteger)counterId completionHandler:(void (^ _Nonnull)(NSInteger, NSInteger, NSInteger, NSError * _Nullable))completionHandler;
/// Creates a Reset Counter packet and send it to the connected device.
/// \param counterId The ID of the counter to reset.
///
/// \param completionHandler Success if the counter was reset.
///
- (void)sendResetCounterWithCounterId:(NSInteger)counterId completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Set Tower ID packet and send it to the connected device.
/// \param towerId The tower ID to set to the tower.
///
/// \param completionHandler Success if the tower ID was set.
///
- (void)sendSetTowerIdWithTowerId:(NSData * _Nonnull)towerId completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Set Tower Serial packet and send it to the connected device.
/// \param towerSerial The tower serial to set to the tower.
///
/// \param completionHandler Success if the tower serial was set.
///
- (void)sendSetTowerSerialWithTowerSerial:(NSString * _Nonnull)towerSerial completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Set Tower Name packet and send it to the connected device.
/// \param towerName The tower name to set to the tower.
///
/// \param completionHandler Success if the tower name was set.
///
- (void)sendSetTowerNameWithTowerName:(NSString * _Nonnull)towerName completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Set Tower Disabled packet and send it to the connected device.
/// \param towerDisabled A flag indicating if the tower should be disabled or not.
///
/// \param towerReason If the tower is disabled, an event is logged by the device and stores the reason why the tower was disabled.
///
/// \param completionHandler Success if the tower was enabled/disabled successfully.
///
- (void)sendSetTowerDisabledWithTowerDisabled:(BOOL)towerDisabled towerReason:(NSString * _Nonnull)towerReason completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Reset Battery Gauge packet and send it to the connected device.
/// \param completionHandler Success if the battery gauge was reset.
///
- (void)sendResetBatteryGaugeWithCompletionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Configure Locker packet and send it to the connected device.
/// \param lockerId Logical locker ID to assign.
///
/// \param lockerPhysicalId Physical port number to assign.
///
/// \param lockerTypeId The ID to assign to the locker.
///
/// \param completionHandler Success if the locker is configured successfully.
///
- (void)sendConfigureLockerWithLockerId:(NSInteger)lockerId lockerPhysicalId:(NSInteger)lockerPhysicalId lockerTypeId:(NSInteger)lockerTypeId completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates an Adjust Clock packet and send it to the connected device.
/// \param adjustClock Number of seconds forward (positive) or backward (negative) in time to adjust the clock
///
/// \param completionHandler Success if the clock was adjusted successfully.
///
- (void)sendAdjustClockWithAdjustClock:(NSInteger)adjustClock completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Reboot Device packet and send it to the connected device.
/// \param completionHandler Success if the device was rebooted.
///
- (void)sendRebootDeviceWithCompletionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Begin Firmware Update packet and send it to the connected device.
/// \param clearAllState A flag indicating if the device should perform a factory reset as part of the update.
///
/// \param completionHandler Success if the device was rebooted into firmware update mode (DFU).
///
- (void)sendBeginFirmwareUpdateWithClearAllState:(BOOL)clearAllState fileURL:(NSURL * _Nonnull)fileURL completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Factory Reset packet and send it to the connected device.
/// \param completionHandler Success if the device was factory reset.
///
- (void)sendFactoryResetWithCompletionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
@end


SWIFT_PROTOCOL("_TtP16HarborLockersSDK17HarborSDKDelegate_")
@protocol HarborSDKDelegate
- (void)harborDidDiscoverTowers:(NSArray<Tower *> * _Nonnull)towers;
@end


@interface NSData (SWIFT_EXTENSION(HarborLockersSDK))
- (NSData * _Nullable)initWithHexString:(NSString * _Nonnull)hexString SWIFT_METHOD_FAMILY(none) SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)cborHexStringFromJSON SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)hexString SWIFT_WARN_UNUSED_RESULT;
+ (NSData * _Nullable)randomCryptoBytes:(NSInteger)count SWIFT_WARN_UNUSED_RESULT;
@end

typedef SWIFT_ENUM(NSInteger, SessionPermission, open) {
  SessionPermissionSync = 0,
  SessionPermissionLockerPickup = 1,
  SessionPermissionLockerDelivery = 2,
  SessionPermissionOwner = 3,
  SessionPermissionTechnician = 4,
  SessionPermissionDeveloper = 5,
};


SWIFT_CLASS("_TtC16HarborLockersSDK5Tower")
@interface Tower : NSObject
@property (nonatomic, readonly, copy) NSString * _Null_unspecified firmwareVersion;
@property (nonatomic, copy) NSData * _Null_unspecified towerId;
@property (nonatomic, copy) NSString * _Null_unspecified towerName;
- (NSString * _Nonnull)peripheralUUID SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif

#elif defined(__x86_64__) && __x86_64__
// Generated by Apple Swift version 5.6.1 (swiftlang-5.6.0.323.66 clang-1316.0.20.12)
#ifndef HARBORLOCKERSSDK_SWIFT_H
#define HARBORLOCKERSSDK_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="HarborLockersSDK",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif



typedef SWIFT_ENUM(NSInteger, DFUError, open) {
  DFUErrorRemoteLegacyDFUSuccess = 1,
  DFUErrorRemoteLegacyDFUInvalidState = 2,
  DFUErrorRemoteLegacyDFUNotSupported = 3,
  DFUErrorRemoteLegacyDFUDataExceedsLimit = 4,
  DFUErrorRemoteLegacyDFUCrcError = 5,
  DFUErrorRemoteLegacyDFUOperationFailed = 6,
  DFUErrorRemoteSecureDFUSuccess = 11,
  DFUErrorRemoteSecureDFUOpCodeNotSupported = 12,
  DFUErrorRemoteSecureDFUInvalidParameter = 13,
  DFUErrorRemoteSecureDFUInsufficientResources = 14,
  DFUErrorRemoteSecureDFUInvalidObject = 15,
  DFUErrorRemoteSecureDFUSignatureMismatch = 16,
  DFUErrorRemoteSecureDFUUnsupportedType = 17,
  DFUErrorRemoteSecureDFUOperationNotPermitted = 18,
  DFUErrorRemoteSecureDFUOperationFailed = 20,
  DFUErrorRemoteSecureDFUExtendedError = 21,
  DFUErrorRemoteExtendedErrorWrongCommandFormat = 22,
  DFUErrorRemoteExtendedErrorUnknownCommand = 23,
  DFUErrorRemoteExtendedErrorInitCommandInvalid = 24,
  DFUErrorRemoteExtendedErrorFwVersionFailure = 25,
  DFUErrorRemoteExtendedErrorHwVersionFailure = 26,
  DFUErrorRemoteExtendedErrorSdVersionFailure = 27,
  DFUErrorRemoteExtendedErrorSignatureMissing = 28,
  DFUErrorRemoteExtendedErrorWrongHashType = 29,
  DFUErrorRemoteExtendedErrorHashFailed = 30,
  DFUErrorRemoteExtendedErrorWrongSignatureType = 31,
  DFUErrorRemoteExtendedErrorVerificationFailed = 32,
  DFUErrorRemoteExtendedErrorInsufficientSpace = 33,
  DFUErrorRemoteExperimentalButtonlessDFUSuccess = 9001,
  DFUErrorRemoteExperimentalButtonlessDFUOpCodeNotSupported = 9002,
  DFUErrorRemoteExperimentalButtonlessDFUOperationFailed = 9004,
  DFUErrorRemoteButtonlessDFUSuccess = 91,
  DFUErrorRemoteButtonlessDFUOpCodeNotSupported = 92,
  DFUErrorRemoteButtonlessDFUOperationFailed = 94,
  DFUErrorRemoteButtonlessDFUInvalidAdvertisementName = 95,
  DFUErrorRemoteButtonlessDFUBusy = 96,
  DFUErrorRemoteButtonlessDFUNotBonded = 97,
/// Providing the DFUFirmware is required.
  DFUErrorFileNotSpecified = 101,
/// Given firmware file is not supported.
  DFUErrorFileInvalid = 102,
/// Since SDK 7.0.0 the DFU Bootloader requires the extended Init Packet.
/// For more details, see:
/// http://infocenter.nordicsemi.com/topic/com.nordic.infocenter.sdk5.v11.0.0/bledfu_example_init.html?cp=4_0_0_4_2_1_1_3
  DFUErrorExtendedInitPacketRequired = 103,
/// Before SDK 7.0.0 the init packet could have contained only 2-byte CRC
/// value, and was optional. Providing an extended one instead would cause
/// CRC error during validation (the bootloader assumes that the 2 first
/// bytes of the init packet are the firmware CRC).
  DFUErrorInitPacketRequired = 104,
  DFUErrorFailedToConnect = 201,
  DFUErrorDeviceDisconnected = 202,
  DFUErrorBluetoothDisabled = 203,
  DFUErrorServiceDiscoveryFailed = 301,
  DFUErrorDeviceNotSupported = 302,
  DFUErrorReadingVersionFailed = 303,
  DFUErrorEnablingControlPointFailed = 304,
  DFUErrorWritingCharacteristicFailed = 305,
  DFUErrorReceivingNotificationFailed = 306,
  DFUErrorUnsupportedResponse = 307,
/// Error raised during upload when the number of bytes sent is not equal to
/// number of bytes confirmed in Packet Receipt Notification.
  DFUErrorBytesLost = 308,
/// Error raised when the CRC reported by the remote device does not match.
/// Service has done 3 attempts to send the data.
  DFUErrorCrcError = 309,
/// The service went into an invalid state. The service will try to close
/// without crashing. Recovery to a know state is not possible.
  DFUErrorInvalidInternalState = 500,
};

/// The state of the DFU Service.
/// <ul>
///   <li>
///     connecting:      Service is connecting to the DFU target.
///   </li>
///   <li>
///     starting:        DFU Service is initializing DFU operation.
///   </li>
///   <li>
///     enablingDfuMode: Service is switching the device to DFU mode.
///   </li>
///   <li>
///     uploading:       Service is uploading the firmware.
///   </li>
///   <li>
///     validating:      The DFU target is validating the firmware.
///   </li>
///   <li>
///     disconnecting:   The iDevice is disconnecting or waiting for disconnection.
///   </li>
///   <li>
///     completed:       DFU operation is completed and successful.
///   </li>
///   <li>
///     aborted:         DFU Operation was aborted.
///   </li>
/// </ul>
typedef SWIFT_ENUM(NSInteger, DFUState, open) {
  DFUStateConnecting = 0,
  DFUStateStarting = 1,
  DFUStateEnablingDfuMode = 2,
  DFUStateUploading = 3,
  DFUStateValidating = 4,
  DFUStateDisconnecting = 5,
  DFUStateCompleted = 6,
  DFUStateAborted = 7,
};

typedef SWIFT_ENUM(NSInteger, Environment, open) {
  EnvironmentDevelopment = 0,
  EnvironmentSandbox = 2,
  EnvironmentProduction = 3,
};


@protocol HarborSDKDelegate;
@class NSString;
@class NSError;
@class Tower;

SWIFT_CLASS("_TtC16HarborLockersSDK9HarborSDK")
@interface HarborSDK : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) HarborSDK * _Nonnull shared;)
+ (HarborSDK * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, strong) id <HarborSDKDelegate> _Null_unspecified delegate;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
- (BOOL)isSyncing SWIFT_WARN_UNUSED_RESULT;
- (void)setBaseURL:(NSString * _Nonnull)baseURL;
- (void)loginWithEmail:(NSString * _Nonnull)email password:(NSString * _Nonnull)password completion:(void (^ _Nonnull)(NSInteger, NSError * _Nullable))completion;
- (void)setAccessToken:(NSString * _Nonnull)token;
- (void)setEnvironment:(enum Environment)environment;
- (void)downloadTowerConfigurationWithCompletion:(void (^ _Nonnull)(BOOL))completion;
- (void)startTowerDiscovery;
- (void)connectToTower:(Tower * _Nonnull)tower completion:(void (^ _Nonnull)(NSString * _Nullable, NSError * _Nullable))completion;
@end



@interface HarborSDK (SWIFT_EXTENSION(HarborLockersSDK))
- (void)dfuProgressDidChangeFor:(NSInteger)part outOf:(NSInteger)totalParts to:(NSInteger)progress currentSpeedBytesPerSecond:(double)currentSpeedBytesPerSecond avgSpeedBytesPerSecond:(double)avgSpeedBytesPerSecond;
- (void)dfuStateDidChangeTo:(enum DFUState)state;
- (void)dfuError:(enum DFUError)error didOccurWithMessage:(NSString * _Nonnull)message;
@end

@class NSData;
enum SessionPermission : NSInteger;
@class NSDate;
@class NSURL;

@interface HarborSDK (SWIFT_EXTENSION(HarborLockersSDK))
- (void)syncWithCompletionHandler:(void (^ _Nonnull)(BOOL, NSError * _Nullable))completionHandler;
/// Establishes a session with a tower. This is a convenience method that can be used if you don’t want to store the Request session payload, payload auth and session seed to send it later. The SDK must be initialized with the provider credentials as the Harbor API will verify it can provide a session with the requested permissions.
/// \param towerId The ID of the tower you want to connect to. If none is provided, it’ll request a session to the connected tower.
///
/// \param duration The duration while the requested session packet will be valid to establish a session.
///
/// \param sessionPermissions Session permissions to request for.
///
/// \param completionHandler Success if the session was granted successfully.
///
- (void)establishSessionWithTowerId:(NSData * _Nullable)towerId duration:(NSInteger)duration sessionPermissions:(enum SessionPermission)sessionPermissions completionHandler:(void (^ _Nonnull)(BOOL, NSError * _Nullable))completionHandler;
/// Requests a session token to connect to a specified tower. The SDK must be initialized with the provider credentials as the Harbor API will verify it can provide a session with the requested permissions. The returned payload, payloadAuth and sessionSeed must be passed to the <code>sendRequestSession</code> method. These values can be stored to connect to the tower while being offline.
/// \param towerId The ID of the tower you want to connect to. If none is provided, it’ll request a session to the connected tower.
///
/// \param duration The duration while the requested session packet will be valid to establish a session.
///
/// \param sessionPermissions Session permissions to request for.
///
/// \param completionHandler A completion handler containing the payload, payloadAuth and sessionSeed that must be provided to the <code>sendRequestSession</code> method to establish the session with the tower.
///
- (void)getSessionRequestWithTowerId:(NSData * _Nullable)towerId duration:(NSInteger)duration sessionPermissions:(enum SessionPermission)sessionPermissions completionHandler:(void (^ _Nonnull)(NSData * _Nullable, NSData * _Nullable, NSData * _Nullable, NSData * _Nullable, NSError * _Nullable))completionHandler;
/// Creates a Request Session packet and send it to the connected device to establish a session. A Grant Session response is automatically processed by this function to execute the completion handler
/// \param payloadAuth Payload auth provided by the server. Contains the signature of the encrypted payload.
///
/// \param payload Encrypted payload provided by the server.
///
/// \param sessionSeed A seed provided by the server to validate a session once it’s established.
///
/// \param completionHandler Success if the session was granted successfully.
///
- (void)sendRequestSessionWithPayloadAuth:(NSData * _Nonnull)payloadAuth payload:(NSData * _Nonnull)payload sessionSeed:(NSData * _Nonnull)sessionSeed completionHandler:(void (^ _Nonnull)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Terminate Session packet and send it to the connected device to terminate a session. If the provided error code is > 0, an <code>errorMessage</code> must be provided and the device will log an Error Event with the provided error code and error message.
/// \param errorCode A code to log in the terminate session event on the device side. May be 0 if no error occurred.
///
/// \param errorMessage The message to store in the error event log.
///
/// \param completionHandler Success if the session was terminated successfully.
///
- (void)sendTerminateSessionWithErrorCode:(NSInteger)errorCode errorMessage:(NSString * _Nullable)errorMessage disconnectAfterSessionTerminated:(BOOL)disconnectAfterSessionTerminated completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Technician/System command. Creates an Install Key packet and send it to the connected device.
/// \param keyId The key slot to replace in the device. Must be a number between 1 and 4.
///
/// \param keyRotation 0 = green, 1 = blue, 2 = fallback
///
/// \param keyExpires The expiration date of the key being installed.
///
/// \param keyData 32 or 64 bytes with the bytes of the key to be installed.
///
/// \param keyLocator A user friendly identifier for the key. This will be returned when requesting the key info.
///
/// \param completionHandler Success if the key was installed.
///
- (void)sendInstallKeyWithKeyId:(NSInteger)keyId keyRotation:(NSInteger)keyRotation keyExpires:(NSDate * _Nonnull)keyExpires keyData:(NSData * _Nonnull)keyData keyLocator:(NSString * _Nonnull)keyLocator completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Technician/System command. Creates a Sunset Key packet and send it to the connected device.
/// \param keyId The key slot to sunset in the device. Must be a number between 1 and 4.
///
/// \param keyRotation 0 = green, 1 = blue, 2 = fallback
///
/// \param completionHandler Success if the key was sunsetted.
///
- (void)sendSunsetKeyWithKeyId:(NSInteger)keyId keyRotation:(NSInteger)keyRotation completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Technician/System command. Creates an Revoke Key packet and send it to the connected device.
/// \param keyId The key slot to revoke in the device. Must be a number between 1 and 4.
///
/// \param keyRotation 0 = green, 1 = blue, 2 = fallback
///
/// \param completionHandler Success if the key was revoked.
///
- (void)sendRevokeKeyWithKeyId:(NSInteger)keyId keyRotation:(NSInteger)keyRotation completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates an Request Sync Status packet and send it to the connected device. In order to validate the response data, you need to check for the error object in the completion handler. If a valid Request Sync Status message is sent, the completion handler will have the Sync Status information.
/// \param completionHandler A completion handler block
///
/// \param syncEventStart The first Event ID available to be read
///
/// \param syncEventCount The amount of available events to read
///
/// \param syncCommandStart The last server command that the device executed.
///
/// \param error An error returned by the device.
///
- (void)sendRequestSyncStatusWithCompletionHandler:(void (^ _Nonnull)(NSInteger, NSInteger, NSInteger, NSError * _Nullable))completionHandler;
/// Creates an Sync Pull packet and send it to the connected device. The device will respond with the events available. In order to validate the response data, you need to check for the error object in the completion handler. If a valid Sync Pull command is sent, the completion handler will have the events information.
/// \param syncEventStart The first Event ID you want to read from the device.
///
/// \param completionHandler A completion handler block
///
/// \param firstEventId The first Event ID returned by the device
///
/// \param syncEventCount The amount of events returned by the device in the payload.
///
/// \param payload Encrypted payload with all the events data. This needs to be sent to the server.
///
/// \param payloadAuth Signature of the payload. This needs to be sent to the server.
///
/// \param error An error returned by the device.
///
- (void)sendSyncPullWithSyncEventStart:(uint32_t)syncEventStart completionHandler:(void (^ _Nonnull)(NSInteger, NSInteger, NSData * _Nonnull, NSData * _Nonnull, NSError * _Nullable))completionHandler;
/// Creates an Sync Push packet and send it to the connected device.
/// \param payload Encrypted payload with all the commands data. This needs to be provided by the server.
///
/// \param payloadAuth Signature of the payload. This needs to be provided by the server.
///
/// \param completionHandler Success if the commands were sent.
///
- (void)sendSyncPushWithPayload:(NSData * _Nonnull)payload payloadAuth:(NSData * _Nonnull)payloadAuth completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Mark Seen Events packet and send it to the connected device.
/// \param syncEventStart Next expected Event ID from the device
///
/// \param completionHandler Success if the seen event was marked.
///
- (void)sendMarkSeenEventsWithSyncEventStart:(uint32_t)syncEventStart completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Reset Event Counter packet and send it to the connected device.
/// \param syncEventStart ID to assign to the device’s log ID counter.
///
/// \param completionHandler Success if the event counter was reset.
///
- (void)sendResetEventCounterWithSyncEventStart:(uint32_t)syncEventStart completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Reset Command Counter packet and send it to the connected device.
/// \param syncCommandStart Next expected command sync ID from the server
///
/// \param completionHandler Success if the command counter was reset.
///
- (void)sendResetCommandCounterWithSyncCommandStart:(uint32_t)syncCommandStart completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates an Add Client Event packet and send it to the connected device.
/// \param clientInfo Data to log in the event (max 500 bytes)
///
/// \param completionHandler Success if the event was logged.
///
- (void)sendAddClientEventWithClientInfo:(NSData * _Nonnull)clientInfo completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Find Available Lockers packet and send it to the connected device. The device will respond with the available lockers info. In order to validate the response data, you need to check for the error object in the completion handler. If a valid Find Available Locker command is sent, the completion handler will have the lockers information.
/// \param completionHandler A completion handler block
///
/// \param availableLockers A map containing locker types as keys, and the amount of available lockers for each type as values. If the device returns an error, this value will be nil.
///
/// \param error An error returned by the device.
///
- (void)sendFindAvailableLockersWithCompletionHandler:(void (^ _Nonnull)(NSDictionary<NSNumber *, NSNumber *> * _Nullable, NSError * _Nullable))completionHandler;
/// Creates a Find Lockers with Token packet and send it to the connected device. The device will respond with the available lockers info that matches the provided details. In order to validate the response data, you need to check for the error object in the completion handler. If a valid Find Available Locker command is sent, the completion handler will have the lockers information.
/// \param matchAvailable Specifies if the device should find an available locker or not.
///
/// \param matchToken Specifies the token the locker should have in order to be considered a match by the device.
///
/// \param completionHandler A completion handler block
///
/// \param availableLockers A map containing locker types as keys, and the amount of available lockers for each type as values. If the device returns an error, this value will be nil.
///
/// \param error An error returned by the device.
///
- (void)sendFindLockersWithTokenWithMatchAvailable:(BOOL)matchAvailable matchToken:(NSData * _Nonnull)matchToken completionHandler:(void (^ _Nonnull)(NSDictionary<NSNumber *, NSNumber *> * _Nullable, NSError * _Nullable))completionHandler;
/// Creates an Open Locker With Token packet and send it to the connected device. The device will respond with the opened locker ID. In order to validate the response data, you need to check for the error object in the completion handler. If a valid Open Locker With Token command is sent, the completion handler will have the opened locker ID.
/// \param payload Encrypted payload provided by the server to open the locker.
///
/// \param payloadAuth Signature of the payload. This needs to be provided by the server.
///
/// \param completionHandler A completion handler block
///
/// \param lockerId The locker ID of the opened locker. Will be -1 if no locker was opened.
///
/// \param error An error returned by the device.
///
- (void)sendOpenLockerWithTokenWithPayload:(NSData * _Nonnull)payload payloadAuth:(NSData * _Nonnull)payloadAuth completionHandler:(void (^ _Nonnull)(NSInteger, NSError * _Nullable))completionHandler;
/// Creates an Open Available Locker packet and send it to the connected device. The device will respond with the opened locker ID. In order to validate the response data, you need to check for the error object in the completion handler. If a valid Open Available Locker command is sent, the completion handler will have the opened locker ID.
/// \param matchLockerType The locker type to be considered by the device. This is a required field to ensure ObjC compatibility. If a negative number is passed, this field will not be sent to the device and any locker in the tower will be considered.
///
/// \param matchAvailable Specifies the required value for the ‘available’ state of lockers to consider.
///
/// \param matchToken If present, locker to be considered must contain this token. By default, no specific token value is required.
///
/// \param lockerToken The new token value to assign to this locker. Leave empty data for auto-assignment.
///
/// \param lockerAvailable The new ‘available’ flag for this locker
///
/// \param clientInfo Opaque data from the client to associate with this delivery.
///
/// \param completionHandler A completion handler block
///
/// \param lockerId The locker ID of the opened locker. Will be -1 if no locker was opened.
///
/// \param error An error returned by the device.
///
- (void)sendOpenAvailableLockerWithMatchLockerType:(NSInteger)matchLockerType matchAvailable:(BOOL)matchAvailable matchToken:(NSData * _Nullable)matchToken lockerToken:(NSData * _Nonnull)lockerToken lockerAvailable:(BOOL)lockerAvailable clientInfo:(NSData * _Nonnull)clientInfo completionHandler:(void (^ _Nonnull)(NSInteger, NSError * _Nullable))completionHandler;
/// Creates a Reopen Locker packet and send it to the connected device. The device will respond with the opened locker ID. In order to validate the response data, you need to check for the error object in the completion handler. If a valid Reopen Locker command is sent, the completion handler will have the opened locker ID.
/// \param completionHandler A completion handler block
///
/// \param lockerId The locker ID of the opened locker. Will be -1 if no locker was opened.
///
/// \param error An error returned by the device.
///
- (void)sendReopenLockerWithCompletionHandler:(void (^ _Nonnull)(NSInteger, NSError * _Nullable))completionHandler;
/// Creates a Check Locker Door packet and send it to the connected device. The device will respond with a bool value indicating if the door is open. If an error occurs, the bool value will be false and the error object will be present.
/// \param completionHandler A completion handler block
///
/// \param doorOpen A flag indicating if the door is open or not. If an error is present, this value can be ignored.
///
/// \param error An error returned by the device.
///
- (void)sendCheckLockerDoorWithCompletionHandler:(void (^ _Nonnull)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Revert Locker State packet and send it to the connected device.
/// \param clientInfo Client information to be logged in an event in case it’s needed.
///
/// \param completionHandler Success if the locker state was reverted.
///
- (void)sendRevertLockerStateWithClientInfo:(NSData * _Nonnull)clientInfo completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Set Keypad Code packet and send it to the connected device.
/// \param keypadCode Code to access the locker, as a string of ASCII digits or the word “auto”. Disables keypad access if empty. Must be between 4 and 10 digits (inclusive).
///
/// \param keypadCodePersists If true, does not erase the keypad access code after a single use.
///
/// \param keypadNextToken Specifies a new active token value to assign if the keypad access code is used.
///
/// \param keypadNextAvailable Specifies a new locker available flag to assign if the keypad access code is used
///
/// \param completionHandler Success if the keypad code was set successfully.
///
- (void)sendSetKeypadCodeWithKeypadCode:(NSString * _Nonnull)keypadCode keypadCodePersists:(BOOL)keypadCodePersists keypadNextToken:(NSData * _Nonnull)keypadNextToken keypadNextAvailable:(BOOL)keypadNextAvailable completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Tap Locker packet and send it to the connected device.
/// \param lockerTapIntervalMS Set the interval between locker “taps” (extra firing of the solenoid to make a tapping sound).
///
/// \param lockerTapCount How many extra times to “tap” the locker (0 for tapping the locker just once).
///
/// \param completionHandler Success if the command was received successfully by the device.
///
- (void)sendTapLockerWithLockerTapIntervalMS:(NSInteger)lockerTapIntervalMS lockerTapCount:(NSInteger)lockerTapCount completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Check All Locker Doors packet and send it to the connected device. In order to validate the response data, you need to check for the error object in the completion handler. If a valid Check All Locker Doors command is sent, the completion handler will have the the locker doors states.
/// \param completionHandler A completion handler block
///
/// \param lockerDoorsOpen Binary string with bitfields indexed by logical locker ID. Each bit index represent a door closed (0) or open (1).
///
/// \param error An error returned by the device.
///
- (void)sendCheckAllLockerDoorsWithCompletionHandler:(void (^ _Nonnull)(NSData * _Nullable, NSError * _Nullable))completionHandler;
/// Creates a Get Device Info packet and send it to the connected device. In order to validate the response data, you need to check for the error object in the completion handler. If a valid Get Device Info command is sent, the completion handler will have the the device info values.
/// \param completionHandler A completion handler block
///
/// \param towerId The tower ID configured in the device
///
/// \param towerName The tower name configured in the device
///
/// \param deviceModel The device model of the device.
///
/// \param deviceSerial The device serial of the device.
///
/// \param towerSerial The tower serial of the device.
///
/// \param firmwareVersion The firmware version running on the device.
///
/// \param mainboardId The ID of the mainboard
///
/// \param shield1Id The ID of the first detected shield.
///
/// \param shield2Id The ID of the second detected shield
///
/// \param solenoidDelay The delay set for the solenoids in the device.
///
/// \param error An error returned by the device.
///
- (void)sendGetDeviceInfoWithCompletionHandler:(void (^ _Nonnull)(NSData * _Nonnull, NSString * _Nonnull, NSString * _Nonnull, NSString * _Nonnull, NSString * _Nonnull, NSString * _Nonnull, NSInteger, NSInteger, NSInteger, NSInteger, NSError * _Nullable))completionHandler;
/// Creates a Get Key Info packet and send it to the connected device. In order to validate the response data, you need to check for the error object in the completion handler. If a valid Get Key Info command is sent, the completion handler will have the the key info values.
/// \param keyId The ID of the Key you want to request the info from.
///
/// \param keyRotation The key rotation you want to request the info from.
///
/// \param completionHandler A completion handler block
///
/// \param keyValid Whether the key is valid now
///
/// \param keySunset Sunset flag indicating if the key is marked as sunsetted or not.
///
/// \param keyExpires An int representing the timestamp when a key will become invalid.
///
/// \param keyLocator Locator data for this key. This is a string associated to the key when it was installed.
///
/// \param error An error returned by the device.
///
- (void)sendGetKeyInfoWithKeyId:(NSInteger)keyId keyRotation:(NSInteger)keyRotation completionHandler:(void (^ _Nonnull)(BOOL, BOOL, NSInteger, NSString * _Nonnull, NSError * _Nullable))completionHandler;
/// Creates a Get Locker Info packet and send it to the connected device. In order to validate the response data, you need to check for the error object in the completion handler. If a valid Get Locker Info command is sent, the completion handler will have the the locker info values.
/// \param lockerId The ID of the locker requesting the info for.
///
/// \param completionHandler A completion handler block
///
/// \param lockerPhysicalId Which port the locker is associated with.
///
/// \param lockerTypeId Configured locker type.
///
/// \param lockerAvailable Whether the locker is available or not.
///
/// \param lockerToken Current locker token, if any is associated.
///
/// \param lockerDisabled Whether the locker is disabled or not.
///
/// \param keypadCode Current keypad code for pickup
///
/// \param keypadNextToken Token to be set after the keypad code is used.
///
/// \param keypadNextAvailable Available flag value to be set after the keypad code is used.
///
/// \param keypadCodePersists A flag indicating if the keypad code persists after it’s used.
///
/// \param error An error returned by the device.
///
- (void)sendGetLockerInfoWithLockerId:(NSInteger)lockerId completionHandler:(void (^ _Nonnull)(NSInteger, NSInteger, NSInteger, BOOL, NSData * _Nonnull, BOOL, NSString * _Nonnull, NSData * _Nonnull, BOOL, BOOL, NSError * _Nullable))completionHandler;
/// Creates a Read Device Status packet and send it to the connected device. In order to validate the response data, you need to check for the error object in the completion handler. If a valid Read Device Status command is sent, the completion handler will have the the device status values.
/// \param completionHandler A completion handler block
///
/// \param temperature Current temperature in Celsius degrees, as a fixed-point integer with 4 bits of fraction.
///
/// \param clockTime Current date and time, according to the RTC
///
/// \param batteryCharge How much charge is remaining in the battery (estimated)
///
/// \param towerDisabled A flag indicating whether the tower is disabled or not.
///
/// \param towerReason The reason given for the tower being disabled.
///
/// \param error An error returned by the device.
///
- (void)sendReadDeviceStatusWithCompletionHandler:(void (^ _Nonnull)(NSInteger, NSInteger, NSInteger, BOOL, NSString * _Nonnull, NSError * _Nullable))completionHandler;
/// Creates a Fire Lock packet and send it to the connected device.
/// \param lockerPhysicalId The port of the lock to fire.
///
/// \param completionHandler Success if the lock was fired.
///
- (void)sendFireLockWithLockerPhysicalId:(NSInteger)lockerPhysicalId completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Control Light packet and send it to the connected device.
/// \param lockerPhysicalId The port of the lock to control the light of.
///
/// \param lockerLightOn Whether to turn on or off the light on the lock.
///
/// \param completionHandler Success if the command was sent successfully.
///
- (void)sendControlLightWithLockerPhysicalId:(NSInteger)lockerPhysicalId lockerLightOn:(BOOL)lockerLightOn completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Read Port Status packet and send it to the connected device. In order to validate the response data, you need to check for the error object in the completion handler. If a valid Read Port Status command is sent, the completion handler will have the the device status values.
/// \param lockerPhysicalId The port to request the status from.
///
/// \param completionHandler A completion handler block
///
/// \param lockerLightOn Whether the light is on or not.
///
/// \param lockerLockFiring Whether the lock is currently firing or not.
///
/// \param lockerDoorOpen Whether the door sensor reports the door being open.
///
/// \param error An error returned by the device.
///
- (void)sendReadPortStatusWithLockerPhysicalId:(NSInteger)lockerPhysicalId completionHandler:(void (^ _Nonnull)(BOOL, BOOL, BOOL, NSError * _Nullable))completionHandler;
/// Creates a Sound Buzzer packet and send it to the connected device.
/// \param buzzerSound An integer interpreted as a pattern of bits. These are to be arranged from least significant to most significant, with each bit representing a 100ms interval. If a bit is set, the buzzer is expected to be on for the interval, otherwise it should be silent for the interval.
///
/// \param completionHandler Success if the command was sent successfully.
///
- (void)sendSoundBuzzerWithBuzzerSound:(NSInteger)buzzerSound completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Set Clock packet and send it to the connected device.
/// \param timestamp A POSIX timestamp to set in the RTC. This time should come from the current device’s time, assuming the device is synced with a time server.
///
/// \param completionHandler Success if the clock was set correctly.
///
- (void)sendSetClockWithTimestamp:(NSInteger)timestamp completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Set Solenoid Delay packet and send it to the connected device.
/// \param solenoidDelay How long to hold the solenoid lock open, in milliseconds.
///
/// \param completionHandler Success if the solenoid delay was set correctly.
///
- (void)sendSetSolenoidDelayWithSolenoidDelay:(NSInteger)solenoidDelay completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Read Keypad packet and send it to the connected device. In order to validate the response data, you need to check for the error object in the completion handler. If a valid Read Keypad command is sent, the completion handler will have the the keypad info.
/// The bit assignments for the keys are as follows:
/// <ul>
///   <li>
///     Bit 0 - key ‘0’
///   </li>
///   <li>
///     Bit 1 - key ‘1’
///   </li>
///   <li>
///     …
///   </li>
///   <li>
///     Bit 9 - key ‘9’
///   </li>
///   <li>
///     Bit 10 - key ‘*’ (if present)
///   </li>
///   <li>
///     Bit 11 - key ‘#’ (if present)
///   </li>
///   <li>
///     Bit 12 - key ‘Enter’ (if present)
///   </li>
/// </ul>
/// \param completionHandler A completion handler block
///
/// \param keysHeld A bitmap of keys currently held down.
///
/// \param keysPressed A bitmap of keys newly pressed.
///
/// \param keysReleased A bitmap of keys newly released.
///
/// \param error An error returned by the device.
///
- (void)sendReadKeypadWithCompletionHandler:(void (^ _Nonnull)(NSInteger, NSInteger, NSInteger, NSError * _Nullable))completionHandler;
/// Creates a Set Locker Token packet and send it to the connected device.
/// \param lockerId The ID of the locker to set the token for.
///
/// \param lockerToken The token to set to the locker.
///
/// \param completionHandler Success if the token was set correctly.
///
- (void)sendSetLockerTokenWithLockerId:(NSInteger)lockerId lockerToken:(NSData * _Nonnull)lockerToken completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Set Locker Available packet and send it to the connected device.
/// \param lockerId The ID of the locker to set as available.
///
/// \param lockerAvailable Whether to set the locker as available or not.
///
/// \param completionHandler Success if the token was set correctly.
///
- (void)sendSetLockerAvailableWithLockerId:(NSInteger)lockerId lockerAvailable:(BOOL)lockerAvailable completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Set Locker Keypad packet and send it to the connected device.
/// \param lockerId The ID of the locker to set the keypad code for.
///
/// \param keypadCode The keypad code to set to the locker.
///
/// \param keypadCodePersists Whether the keypad code will persist after it’s used to open the locker.
///
/// \param keypadNextToken The token to assign to the locker if it’s open with the Keypad code.
///
/// \param keypadNextAvailable The availability flag to assign to the locker once it’s opened with the Keypad.
///
/// \param completionHandler Success if the token was set correctly.
///
- (void)sendSetLockerKeypadWithLockerId:(NSInteger)lockerId keypadCode:(NSString * _Nonnull)keypadCode keypadCodePersists:(BOOL)keypadCodePersists keypadNextToken:(NSData * _Nonnull)keypadNextToken keypadNextAvailable:(BOOL)keypadNextAvailable completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Set Locker Disabled packet and send it to the connected device.
/// \param lockerId The ID of the locker to set the disabled flag.
///
/// \param lockerDisabled Whether to disable the locker or not.
///
/// \param completionHandler Success if the token was set correctly.
///
- (void)sendSetLockerDisabledWithLockerId:(NSInteger)lockerId lockerDisabled:(BOOL)lockerDisabled completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Read Counter packet and send it to the connected device. In order to validate the response data, you need to check for the error object in the completion handler. If a valid Read Counter command is sent, the completion handler will have the the counter value.
/// \param counterId The ID of the counter to read the value from.
///
/// \param completionHandler A completion handler block
///
/// \param counterValue The value of the counter
///
/// \param counterLastReset A POSIX timestamp when the counter was last reset.
///
/// \param error An error returned by the device.
///
- (void)sendReadCounterWithCounterId:(NSInteger)counterId completionHandler:(void (^ _Nonnull)(NSInteger, NSInteger, NSInteger, NSError * _Nullable))completionHandler;
/// Creates a Reset Counter packet and send it to the connected device.
/// \param counterId The ID of the counter to reset.
///
/// \param completionHandler Success if the counter was reset.
///
- (void)sendResetCounterWithCounterId:(NSInteger)counterId completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Set Tower ID packet and send it to the connected device.
/// \param towerId The tower ID to set to the tower.
///
/// \param completionHandler Success if the tower ID was set.
///
- (void)sendSetTowerIdWithTowerId:(NSData * _Nonnull)towerId completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Set Tower Serial packet and send it to the connected device.
/// \param towerSerial The tower serial to set to the tower.
///
/// \param completionHandler Success if the tower serial was set.
///
- (void)sendSetTowerSerialWithTowerSerial:(NSString * _Nonnull)towerSerial completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Set Tower Name packet and send it to the connected device.
/// \param towerName The tower name to set to the tower.
///
/// \param completionHandler Success if the tower name was set.
///
- (void)sendSetTowerNameWithTowerName:(NSString * _Nonnull)towerName completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Set Tower Disabled packet and send it to the connected device.
/// \param towerDisabled A flag indicating if the tower should be disabled or not.
///
/// \param towerReason If the tower is disabled, an event is logged by the device and stores the reason why the tower was disabled.
///
/// \param completionHandler Success if the tower was enabled/disabled successfully.
///
- (void)sendSetTowerDisabledWithTowerDisabled:(BOOL)towerDisabled towerReason:(NSString * _Nonnull)towerReason completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Reset Battery Gauge packet and send it to the connected device.
/// \param completionHandler Success if the battery gauge was reset.
///
- (void)sendResetBatteryGaugeWithCompletionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Configure Locker packet and send it to the connected device.
/// \param lockerId Logical locker ID to assign.
///
/// \param lockerPhysicalId Physical port number to assign.
///
/// \param lockerTypeId The ID to assign to the locker.
///
/// \param completionHandler Success if the locker is configured successfully.
///
- (void)sendConfigureLockerWithLockerId:(NSInteger)lockerId lockerPhysicalId:(NSInteger)lockerPhysicalId lockerTypeId:(NSInteger)lockerTypeId completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates an Adjust Clock packet and send it to the connected device.
/// \param adjustClock Number of seconds forward (positive) or backward (negative) in time to adjust the clock
///
/// \param completionHandler Success if the clock was adjusted successfully.
///
- (void)sendAdjustClockWithAdjustClock:(NSInteger)adjustClock completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Reboot Device packet and send it to the connected device.
/// \param completionHandler Success if the device was rebooted.
///
- (void)sendRebootDeviceWithCompletionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Begin Firmware Update packet and send it to the connected device.
/// \param clearAllState A flag indicating if the device should perform a factory reset as part of the update.
///
/// \param completionHandler Success if the device was rebooted into firmware update mode (DFU).
///
- (void)sendBeginFirmwareUpdateWithClearAllState:(BOOL)clearAllState fileURL:(NSURL * _Nonnull)fileURL completionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
/// Creates a Factory Reset packet and send it to the connected device.
/// \param completionHandler Success if the device was factory reset.
///
- (void)sendFactoryResetWithCompletionHandler:(void (^ _Nullable)(BOOL, NSError * _Nullable))completionHandler;
@end


SWIFT_PROTOCOL("_TtP16HarborLockersSDK17HarborSDKDelegate_")
@protocol HarborSDKDelegate
- (void)harborDidDiscoverTowers:(NSArray<Tower *> * _Nonnull)towers;
@end


@interface NSData (SWIFT_EXTENSION(HarborLockersSDK))
- (NSData * _Nullable)initWithHexString:(NSString * _Nonnull)hexString SWIFT_METHOD_FAMILY(none) SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)cborHexStringFromJSON SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)hexString SWIFT_WARN_UNUSED_RESULT;
+ (NSData * _Nullable)randomCryptoBytes:(NSInteger)count SWIFT_WARN_UNUSED_RESULT;
@end

typedef SWIFT_ENUM(NSInteger, SessionPermission, open) {
  SessionPermissionSync = 0,
  SessionPermissionLockerPickup = 1,
  SessionPermissionLockerDelivery = 2,
  SessionPermissionOwner = 3,
  SessionPermissionTechnician = 4,
  SessionPermissionDeveloper = 5,
};


SWIFT_CLASS("_TtC16HarborLockersSDK5Tower")
@interface Tower : NSObject
@property (nonatomic, readonly, copy) NSString * _Null_unspecified firmwareVersion;
@property (nonatomic, copy) NSData * _Null_unspecified towerId;
@property (nonatomic, copy) NSString * _Null_unspecified towerName;
- (NSString * _Nonnull)peripheralUUID SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif

#endif
